||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

|| NOTE: define first to avoid load order problem
{def cc-upper =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ" asa CharClass
}
|| ==========
|| NOTE: TEMPORARY SCAFFOLDING
{import * from CURL.LANGUAGE.SOURCE}
{define-class public DataObjectTraits-for {inherits StandardDataObjectTraits}
  {constructor public {default
                          type:ClassType,
                          name:#String = null,
                          namespace:#String = null}
    def qualified-name =
        {format "%s.%s",
            {if-non-null namespace then namespace
             else
                {if-non-null package-name = type.package.name
                 then package-name
                 else ""}},
            {if-non-null name then name
             else type.name}}
    def members = {StringArray}
    def fields = 
        {type.get-members 
            filter = ClassMember.set-property-filter}
    {for f in fields do
        {members.append f.name}}
    {construct-super
        qualified-name,
        members,
        dynamic? = false,
        externalizable? = {type.subtype-of? Externalizable}}
||--    {output {{self.to-source}.get-text}}
  }
  {method public {to-source}:CurlSource
    def members = {{Array-of CurlSource}}
    {for m in self.members do
        {if not members.empty? then
            {members.append {Operator OperatorKind.Comma}}
            {members.append {TextFragment "\n", true}}}
        {members.append {Literal m}}}
    {return
        {expand-template
            || NOTE: keep flush left
{DataObjectTraits
    ?{Literal self.name},
    dynamic? = ?{Literal self.dynamic?},
    externalizable? = ?{Literal self.externalizable?},
    {StringArray
        ?members}
}   
        }}
  }
}
|| ====================
|| TODO:
|| - intern traits by name
|| - error-if-exists?
|| - consolidate slots in adapter struct

{define-class public AMFObjectAdapter
  field public constant type:ClassType
  field public constant traits:DataObjectTraits
  field public constant name:String
  field public constant factory:{proc-type {}:Object}
  field public constant reader:{proc-type {Object, AMF3Deserializer}:void}
  field public constant writer:{proc-type {Object, AMF3Serializer}:void}
  {constructor public {default
                          type:ClassType,
                          traits:DataObjectTraits = {traits-for type}
                      }
    set self.type = type
    set self.traits = traits
    set self.name = traits.name
    set self.factory = {factory-for type}
    set self.reader = {reader-for type, traits}
    set self.writer = {writer-for type, traits}
  }
}

{define-class public AMFObjectAdapters
  field constant traits-for-class:{HashTable-of ClassType, DataObjectTraits}
  field constant adapters-by-name:{HashTable-of String, AMFObjectAdapter}
||--  field private constant traits-for-name:{HashTable-of String, DataObjectTraits}
||--  field private constant class-for-name:{HashTable-of String, ClassType}
||--  field private constant factory-for-name:{HashTable-of String, {proc-type {}:Object}}
||--  field private constant reader-for-name:{HashTable-of String, {proc-type {Object, AMF3Deserializer}:void}}
||--  field private constant writer-for-name:{HashTable-of String, {proc-type {Object, AMF3Serializer}:void}}
  
  {constructor public {default
                          default-mappings?:bool = true
                      }
    set self.traits-for-class = {{HashTable-of ClassType, DataObjectTraits}}
    set self.adapters-by-name = {{HashTable-of String, AMFObjectAdapter}}
||--    set self.traits-for-name = {{HashTable-of String, DataObjectTraits}}
||--    set self.class-for-name = {{HashTable-of String, ClassType}}
||--    set self.factory-for-name = {{HashTable-of String, {proc-type {}:Object}}}
||--    set self.reader-for-name = {{HashTable-of String, {proc-type {Object, AMF3Deserializer}:void}}}
||--    set self.writer-for-name = {{HashTable-of String, {proc-type {Object, AMF3Serializer}:void}}}
    {if default-mappings? then
        {self.register-defaults}}
  }
  {method public {class-for name:String}:(ClassType, bool)
    def (adapter, adapter?) = {self.adapters-by-name.get-if-exists name}
    {return
        {if adapter?
         then (adapter.type, true)
         else ({uninitialized-value-for-type ClassType}, false)
        }}
  }
  {method public {factory-for name:String}:({proc-type {}:Object}, bool)
    def (adapter, adapter?) = {self.adapters-by-name.get-if-exists name}
    {return
        {if adapter?
         then (adapter.factory, true)
         else ({uninitialized-value-for-type {proc-type {}:Object}}, false)
        }}
  }
  {method public {reader-for name:String}:({proc-type {Object, AMF3Deserializer}:void}, bool)
    def (adapter, adapter?) = {self.adapters-by-name.get-if-exists name}
    {return
        {if adapter?
         then (adapter.reader, true)
         else ({uninitialized-value-for-type {proc-type {Object, AMF3Deserializer}:void}}, false)
        }}
  }
  {method public {writer-for name:String}:({proc-type {Object, AMF3Serializer}:void}, bool)
    def (adapter, adapter?) = {self.adapters-by-name.get-if-exists name}
    {return
        {if adapter?
         then (adapter.writer, true)
         else ({uninitialized-value-for-type {proc-type {Object, AMF3Serializer}:void}}, false)
        }}
  }
  {method public {register-class
                     type:ClassType,
                     traits:DataObjectTraits = {traits-for type}
                 }:void
    def name = traits.name
    set self.traits-for-class[type] = traits
      set self.adapters-by-name[name] =
          {AMFObjectAdapter type, traits = traits}
||--    set self.traits-for-name[name] = traits
||--    set self.class-for-name[name] = type
||--    set self.factory-for-name[name] = {factory-for type}
||--    set self.reader-for-name[name] = {reader-for type, traits}
||--    set self.writer-for-name[name] = {writer-for type, traits}
  }
  {method public {register-package
                     package:Package
                 }:void
    {for m in {package.get-members} do
        {type-switch {m.get-value}
         case type:ClassType do
            {if-non-null traits = {class-traits-for type} then
                {self.register-class type, traits = traits}
            }}}
  }
  {method public {register-defaults}:void
    || TODO: declare traits explicitly in COM.CURL.CDK.MESSAGES
    def MESSAGES = "flex.messaging.messages"
    def message-types =
        {{Array-of ClassType}
            COM.CURL.CDK.MESSAGES.ErrorMessage,
            COM.CURL.CDK.MESSAGES.AcknowledgeMessage,
            COM.CURL.CDK.MESSAGES.RemotingMessage,
            COM.CURL.CDK.MESSAGES.CommandMessage}
    
    {for type in message-types do
        {self.register-class type,
            traits = {DataObjectTraits-for type, namespace = MESSAGES}}
    }
    
    || special cases
    {self.register-class COM.CURL.CDK.MESSAGES.AcknowledgeMessageExt,
        traits =
            {DataObjectTraits
                "DSK",
                {StringArray},
                dynamic? = false,
                externalizable? = true}
    }

    {self.register-class ArrayCollection,
        traits =
            {DataObjectTraits
                "flex.messaging.io.ArrayCollection",
                {StringArray},
                dynamic? = false,
                externalizable? = true}
    }
  }
  def public standard = {AMFObjectAdapters}
}
|| traits discovery
|| --------------------
{define-proc {class-traits-for type:ClassType}:#DataObjectTraits
    {return
        {if-non-null class-traits = {type.get-class-variable "traits"} then
            {type-switch {class-traits.get-value}
             case traits:DataObjectTraits do
                traits
             else
                {error
                    {message Expected DataObjectTraits for {value type}.traits
                        but found {value class-traits}}}}
         else null}}
}
{define-proc {traits-for type:ClassType}:DataObjectTraits
    {return
        {if-non-null traits = {class-traits-for type} then
            traits
         else
            {DataObjectTraits-for type}}}
}
|| name transformation
|| --------------------
{define-proc {curlify-name name:String}:String
||--    def cc-upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" asa CharClass
    || unchanged if no uppercase
    def i = {name.find-char-class cc-upper}
    {if i < 0 then
        {return name}}
    || work buffer
    def buf = {StringBuf}
    let prev?:bool = true
    || copy characters
    {for c in name do
        def upper? = cc-upper[c]
        {if upper? and not prev? then
            {buf.append '-'}}
        set prev? = upper?
        {buf.append {char-downcase c}}}
    {return {buf.to-String}}        
}
{define-proc {javafy-name name:String}:String
    || unchanged if no dash
    def i = {name.find '-'}
    {if i < 0 then
        {return name}}
    || work buffer
    def buf = {StringBuf}
    let upcase?:bool = false
    || copy characters, skipping dashes, upcasing following character
    {for c in name do
        set upcase? = 
            {switch c
             case '-' do
                true
             else
                {buf.append
                    {if upcase? then
                        {char-upcase c}
                     else c}}
                false}}
    {return {buf.to-String}}        
}
|| code generation
|| --------------------
{define-proc {factory-for type:ClassType}:{proc-type {}:Object}
    || NOTE: assumes no-arg default constructor
    def src =
        {expand-template
            {proc {}:Object
                {return
                    {?{Literal type}}
                }}
        }
    def factory = {evaluate src} asa {proc-type {}:Object}
    {return factory}
}
{define-proc {writer-for
                 type:ClassType,
                 traits:DataObjectTraits,
                 remote-traits?:bool = false
             }:{proc-type {Object, AMF3Serializer}:void}
    def statements = {{Array-of CurlSource}}
    {for member in traits.members do
        || NOTE: distinguish local vs remote trait names
        || - if remote, need to curlify
        def m =
            {if remote-traits? then
                {curlify-name member}
             else member}
        {statements.append
            {expand-template
                {out.write-one self.?{Identifier m}}
            }}}
    def src =
        {expand-template
            {proc {obj:Object, out:AMF3Serializer}:void
                def self = obj asa ?{Literal type} 
                ?statements
            }
        }
    def writer =
        {evaluate src,
            package = {OpenPackage {this-package}}
        } asa {proc-type {Object, AMF3Serializer}:void}
    {return writer}
}
{define-proc {reader-for
                 type:ClassType,
                 traits:DataObjectTraits,
                 remote-traits?:bool = true
             }:{proc-type {Object, AMF3Deserializer}:void}
    def statements = {{Array-of CurlSource}}
    {for member in traits.members do
        || NOTE: distinguish local vs remote trait names
        || - if remote, need to curlify
        def m =
            {if remote-traits? then
                {curlify-name member}
             else member}
        def t =
            {if-non-null p = {type.get-property-for-get m} then
                p.type
             else
                any}
        {statements.append
            {expand-template
                set self.?{Identifier m} = {in.read-one} asa ?{Literal t}
            }}}
    def src =
        {expand-template
            {proc {obj:Object, in:AMF3Deserializer}:void
                def self = obj asa ?{Literal type} 
                ?statements
            }
        }
    def reader =
        {evaluate src,
            package = {OpenPackage {this-package}}
        } asa {proc-type {Object, AMF3Deserializer}:void}
    {return reader}
}


|| ========== \\
|| === EXPERIMENTAL ==
{define-class public DataObjectWrapper {inherits SealedDataObject}
  field constant _subject:Object
  {getter public {subject}:Object
    {return self._subject}
  }
  {factory public implicit {default subject:Object}:DataObjectWrapper
    def type = {type-of subject} asa ClassType
    def create = {DynamicData-for.construct type}
    def wrapper =
        {with-compiler-directives allow-any-calls? = true do
            {create subject} asa DataObject}
    {return wrapper}
  }
  {constructor public {internal
                          subject:Object,
                          type:ClassType,
                          traits:DataObjectTraits = {traits-for type}
                      }
    set self._subject = subject
    {construct-super traits}
  }
  {method public {get key:String}:any
    def (val, val?) = {self.get-if-exists key}
    {return
        {if val? then val
         else
            {error {message Key '{value key}' not found in {value self}}}}}
  }
  {method public {get-if-exists key:String}:(any, bool)
    def index = {self.traits.index-for key}
    {return
        {if index >= 0 then
            def val = {get-public-property self.subject, key}
            (val, true)
         else
            (null, false)}}
  }
  {method public {set key:String, val:any}:void
    let changed?:bool = self[key] != val
    {if changed? then
        {self.preserve-original-data}
        {set-public-property self.subject, key, self[key]}
        {self.trigger-data-changed key}}
  }
  {method protected {preserve-original-data}:void
    def members = self.traits.members
    {if self.original-data == null then
        def data = {FastArray.from-size members.size, null}
        {for k key i in members do
            set data[i] = self[k]}
        set self.original-data = data}
  }
  {method public {set-internal-key key:String, val:any}:void
    {set-public-property self.subject, key, val}
  }
  {method public {set-internal index:int, val:any}:void
    def key = self.traits.members[index]
    {self.set-internal-key key, val}
  }
}
{define-class public {DynamicData-for T:ClassType}
  {inherits DataObjectWrapper}
  {constructor public {default subject:T}
    {construct-super.internal subject, T}
  }
  {getter public {subject}:T
    {return super.subject asa T}
  }
}
|| ========== //

