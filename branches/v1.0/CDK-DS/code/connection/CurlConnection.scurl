||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public CurlConnection
  field public object-encoding:int = CurlConnection.AMF3
  field public client:any
  field protected uri:#Url

  let public constant AMF3:int = 3

  let public response-uri-count:int = 1

  {constructor public {default}
  }

  {method public {connect uri:Url, ...}:void
    set self.uri = uri
    || TODO: What else happens here?
  }

  {method public {close}:void
  }

  || From the Flex docs for NetConnection.call():
  ||
  || command:String - A method specified in the form [objectPath/]method. For
  ||                  example, the someObject/doSomething command tells the
  ||                  remote server to invoke the
  ||                  clientObject.someObject.doSomething() method, with all the
  ||                  optional ... arguments parameters. If the object path is
  ||                  missing, clientObject.doSomething() is invoked on the
  ||                  remote server.
  {method public {call
                     command:#String = null,
                     responder:#ConnectionResponder = null,
                     ...:any
                 }:void
    {if-non-null u = self.uri then
        let envelope:AMFEnvelope = {new AMFEnvelope}
        let amf-body:AMFBody =
            {new AMFBody,
                target-uri = {if-non-null command then command else "null"},
                response-uri = "/" & CurlConnection.response-uri-count,
                length = AMF0Serializer.UNKNOWN_CONTENT_LENGTH,
                {new {Array-of any}, {splice ...}}
            }
        {inc CurlConnection.response-uri-count}
        {envelope.add-body amf-body}

        let request-data:AMFHttpRequestData =
            {new AMFHttpRequestData, {envelope.serialize}}
        let http-file:HttpFile = {u.instantiate-File} asa HttpFile
        {if-debuggable
            {for x in ... do
                {output "sending message: " & x}
            }}
        {http-file.http-async-read-open-byte
            request-data = request-data,
            request-method = "post",
            {on e:AsyncFileOpenEvent do
                {if-non-null ex = e.exception then
                    {if-non-null responder then
                        def err = {new ErrorMessage}
                        set err.fault-code = "Client.Ping.Failed"
                        set err.fault-string = "error"
                        set err.fault-detail = ex.message
                        set err.root-cause = amf-body
                        {responder.status err}
                    }
                 elseif e.canceled? then
                    {if-non-null responder then
                        def err = {new ErrorMessage}
                        set err.fault-code = "Client.Ping.Canceled"
                        set err.fault-string = "warn"
                        set err.extended-data = e
                        {responder.status err}
                    }
                 else
                    def response = e.stream asa ByteInputStream
                    || Note: this will do blocking reads.
                    def ret = {AMFEnvelope.deserialize response}
                    def headers = ret.headers
                    def bodies = ret.bodies
                    || Remember to close the stream.
                    {response.close}
                    {if-non-null responder then
                        || TODO: What can we reasonably expect in the envelope?
                        ||       The responder's result handler takes a single
                        ||       IMessage argument. Can we stop at one message
                        ||       from bodies? What if it's an ErrorMessage? Can
                        ||       the case exist where there are no messages?
                        let msg:#IMessage = null
                        {for body in bodies do
                            set msg = {self.extract-message body.data}
                            {if-non-null msg then
                                || TODO: For now we're taking the first message
                                ||       we find.
                                {break}
                            }
                        }
                        {type-switch msg
                         case err:ErrorMessage do
                            {responder.status err}
                         case ack:AcknowledgeMessage do
                            {responder.result ack}
                         case cmd:CommandMessage do
                            {responder.result cmd}
                         else
                            def err = {new ErrorMessage}
                            set err.fault-code = "Unable to find a Message"
                            set err.fault-string = "warn"
                            set err.extended-data = bodies
                            set err.root-cause = e
                            {responder.status err}
                        }
                    }
                }
            }
        }
    }
  }

  {method protected {host-and-port url:Url}:(String, uint16)
    {type-switch url.stem
     case shd:StemHttpDirectory do
        {assert {shd.name.prefix? "http:"} or {shd.name.prefix? "https:"}}
        {return shd.host, {shd.get-port} asa uint16}
     else
        {error "Not an http: url"}
    }
  }

  || TODO: audit adapter registration
  {method protected {extract-message x:any}:#IMessage
    {return
        {type-switch x
         case msg:IMessage do
            || NOTE: counting on proper serialization registration
            msg
         else
            {error {message Expected IMessage but got {value x}}}
        }}
  }
  || TODO: This is ugly. Figure out an acceptable way to inspect an any. I think
  ||       we're, unfortunately, stuck with what BlazeDS sends back.
||--  {method protected {extract-message x:any}:#IMessage
||--    {type-switch x
||--     case msg:IMessage do
||--        {return msg}
||--     case amf-obj:DataObject do
||--        {switch amf-obj.traits.name
||--         case "flex.messaging.messages.ErrorMessage" do
||--            def err = {new ErrorMessage}
||--            set err.headers = amf-obj["headers"] asa {HashTable-of String, any}
||--            set err.body = amf-obj["body"]
||--            set err.message-id = amf-obj["messageId"] asa String
||--            set err.client-id = amf-obj["clientId"] asa #String
||--            set err.correlation-id =
||--                {if-non-null d = amf-obj["correlationId"] then
||--                    d asa String
||--                 else
||--                    ""
||--                }
||--            set err.destination =
||--                {if-non-null d = amf-obj["destination"] then
||--                    d asa String
||--                 else
||--                    ""
||--                }
||--            set err.timestamp = amf-obj["timestamp"] asa double
||--            set err.time-to-live = amf-obj["timeToLive"] asa double
||--            set err.fault-code = amf-obj["faultCode"] asa #String
||--            set err.fault-string = amf-obj["faultString"] asa #String
||--            set err.fault-detail = amf-obj["faultDetail"] asa #String
||--            set err.extended-data = amf-obj["extendedData"]
||--            set err.root-cause = amf-obj["rootCause"]
||--            {return err}
||--         case "flex.messaging.messages.AcknowledgeMessage" do
||--            def ack = {new AcknowledgeMessage}
||--            set ack.headers = amf-obj["headers"] asa {HashTable-of String, any}
||--            set ack.body = amf-obj["body"]
||--            set ack.message-id = amf-obj["messageId"] asa String
||--            set ack.client-id = amf-obj["clientId"] asa #String
||--            set ack.correlation-id =
||--                {if-non-null d = amf-obj["correlationId"] then
||--                    d asa String
||--                 else
||--                    ""
||--                }
||--            set ack.destination =
||--                {if-non-null d = amf-obj["destination"] then
||--                    d asa String
||--                 else
||--                    ""
||--                }
||--            set ack.time-to-live = amf-obj["timeToLive"] asa double
||--            set ack.timestamp = amf-obj["timestamp"] asa double
||--            || TODO: Still need to return the actual message data the server
||--            ||       sent us.
||--            {return ack}
||--         case "flex.messaging.messages.CommandMessage" do
||--            def command-message = {new CommandMessage}
||--            set command-message.headers =
||--                amf-obj["headers"] asa {HashTable-of String, any}
||--            set command-message.body = amf-obj["body"] asa {Array-of any}
||--            set command-message.message-id = amf-obj["messageId"] asa String
||--            set command-message.client-id = amf-obj["clientId"] asa #String
||--            set command-message.correlation-id =
||--                {if-non-null d = amf-obj["correlationId"] then
||--                    d asa String
||--                 else
||--                    ""
||--                }
||--            set command-message.destination =
||--                {if-non-null d = amf-obj["destination"] then
||--                    d asa String
||--                 else
||--                    ""
||--                }
||--            set command-message.operation = amf-obj["operation"] asa uint
||--            set command-message.timestamp = amf-obj["timestamp"] asa double
||--            set command-message.time-to-live = amf-obj["timeToLive"] asa double
||--            {return command-message}
||--         else
||--            let msg:#IMessage = null
||--            {with-compiler-directives allow-any-calls? = true do
||--                {try
||--                    def collection = {x.to-Iterator}
||--                    {for it in collection do
||--                        set msg = {self.extract-message it}
||--                        {if-non-null msg then
||--                            {return msg}
||--                        }
||--                    }
||--                 catch e:Exception do
||--                    || Catch exceptions thrown when something doesn't support
||--                    || {to-Iterator}.
||--                    set msg = null
||--                }
||--            }
||--            {return msg}
||--        }
||--     else
||--        let msg:#IMessage = null
||--        {with-compiler-directives allow-any-calls? = true do
||--            {try
||--                def collection = {x.to-Iterator}
||--                {for it in collection do
||--                    set msg = {self.extract-message it}
||--                    {if-non-null msg then
||--                        {return msg}
||--                    }
||--                }
||--             catch e:Exception do
||--                || Catch exceptions thrown when something doesn't support
||--                || {to-Iterator}.
||--                set msg = null
||--            }
||--        }
||--        {return msg}
||--    }
||--    {return null}
||--  }
}
