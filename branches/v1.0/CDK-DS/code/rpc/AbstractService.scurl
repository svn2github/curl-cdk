||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public abstract AbstractService {inherits EventTarget}
  field protected _request-timeout:Time
  field protected async-request:AsyncRequest

  {constructor public {default
                          endpoint:#Url = null,
                          destination:String = "",
                          channel-set:#ChannelSet = null,
                          ...:EventHandler
                      }
    {construct-super ...}

    set self.async-request =
        {AsyncRequest endpoint = endpoint, destination = destination, channel-set = channel-set}
  }

  {getter public {channel-set}:#ChannelSet
    {return self.async-request.channel-set}
  }

  {setter public {channel-set cs:#ChannelSet}void
    set self.async-request.channel-set = cs
  }

  {getter public {destination}:String
    {return self.async-request.destination}
  }

  {setter public {destination d:String}:void
    set self.async-request.destination = d
  }

  {getter public {request-timeout}:Time
    {return self.async-request.request-timeout}
  }

  {setter public {request-timeout t:Time}void
    {if self.request-timeout != t then
        set self.async-request.request-timeout = t
    }
  }

  {method public {disconnect}:void
    {self.async-request.disconnect}
  }

  {method public {logout}:void
    {self.async-request.logout}
  }

  {method public {set-credentials
                     username:#String,
                     password:#String,
                     charset:#String = null
                 }:void
    {self.async-request.set-credentials username, password, charset = charset}
  }

  {method public {set-remote-credentials
                     remote-username:#String,
                     remote-password:#String,
                     charset:#String = null
                 }:void
    {self.async-request.set-remote-credentials
        remote-username, remote-password, charset = charset
    }
  }

  {method public {send name:String, async?:bool = false, ...:any}:void
        def operation = {self.get-operation name}
        set operation.async? = async?
        {operation.send ...}
||--        {if not async? then
||--            {self.invoke-method name, ...}
||--         else
||--            {self.async-invoke-method name, ...}
||--        }
  }

  {method public {get-operation name:String}:AbstractOperation
    def operation =
        {Operation remote-object = self, name = name, async-request = self.async-request}
    {return operation}
  }

  || This provides a hook for custom event pre-processing.
  {method public {dispatch-event event:Event}:void
    {self.enqueue-event event}
  }

  {method protected {has-token-responders? event:Event}:bool
    {type-switch event
     case ae:AbstractEvent do
        {if-non-null ae.token then
            {if {ae.token.has-responder?} then
                {return true}
            }
        }
    }
    {return false}
  }

  {method public {on-fault-event e:FaultEvent}:void}
  {method public {on-invoke-event e:InvokeEvent}:void}
  {method public {on-result-event e:ResultEvent}:void}
}
