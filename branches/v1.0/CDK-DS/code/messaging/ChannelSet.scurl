||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public ChannelSet {inherits EventTarget}
  field private _authenticated?:bool = false
  field private _connected?:bool = false
  field private connecting?:bool = false
  field private clustered?:bool = false
  field private _configured?:bool = false
  || TODO: Implement a setter that checks configured? then removes existing
  ||       channels and adds new channels.
  field private channels:{Array-of #Channel}
||--  field private _channel-ids:#{Array-of #String}
  field private _current-channel:#Channel
  field private current-channel-index:int = -1
  field private constant _message-agents:{Array-of MessageAgent}
  field private credentials:#String
  field private credentials-charset:#String
  field private auth-agent:#AuthenticationAgent
  field private constant pending-messages:{Set-of IMessage}
  field private constant pending-sends:{Array-of PendingSend}
  field private constant channel-event-handler:EventHandler

  {constructor public {default
||--                          channel-ids:#{Array-of #String} = null
||--                          , clustered-with-load-balancing?:bool = false
                          channel:#Channel = null,
                          channels:#{Array-of #Channel} = null
                      }
    {construct-super}
    {if channel != null and channels != null then
        {error "Only one of channel or channels may be supplied."}
    }
    set self.channel-event-handler =
        {on e:MessageEvent do
            {self.message-handler e}
        }
    set self.channels = {new {Array-of #Channel}}
    {if-non-null channels then
        {for c in channels do
            {if-non-null c then
                {self.add-channel c}
            }
        }
     else
        {if-non-null channel then
            {self.add-channel channel}
        }
    }
||--    {if-non-null channel-ids then
||--        set self._channel-ids = channel-ids
||--        {if-non-null ids = self._channel-ids then
||--            {self.channels.set-size ids.size, null}
||--        }
||--        set self._configured? = true
||--     else
        set self._configured? = self.channels.empty?
||--    }
    set self._message-agents = {new {Array-of MessageAgent}}
    set self.pending-messages = {new {Set-of IMessage}}
    set self.pending-sends = {new {Array-of PendingSend}}

    {self.add-event-handler
        {on e:ChannelEvent do
            {for agent in self._message-agents do
                {switch e.type
                 case ChannelEvent.CONNECT do
                    {agent.channel-connect-handler e}
                 case ChannelEvent.DISCONNECT do
                    {agent.channel-disconnect-handler e}
                }
            }
        }
    }
    {self.add-event-handler
        {on e:ChannelFaultEvent do
            {for agent in self._message-agents do
                {agent.channel-fault-handler e}
            }
        }
    }
  }

  {getter public {configured?}:bool
    {return self._configured?}
  }

  {getter public {connected?}:bool
    {return self._connected?}
  }

||--  {getter public {channel-ids}:#{Array-of #String}
||--    {if-non-null self._channel-ids then
||--        {return self._channel-ids}
||--     else
||--        def ids = {new {Array-of #String}}
||--        {for channel in self.channels do
||--            {if-non-null channel then
||--                {ids.append channel.id}
||--             else
||--                {ids.append null}
||--            }
||--        }
||--        {return ids}
||--    }
||--  }

  {getter public {current-channel}:#Channel
    {return self._current-channel}
  }

||--  {setter public {current-channel channel:#Channel}:void
||--    set self._current-channel = channel
||--  }

  {getter public {message-agents}:{Array-of MessageAgent}
    {return self._message-agents}
  }

  {getter public {authenticated?}:bool
    {return self._authenticated?}
  }

  {method public {set-authenticated?
                     b?:bool,
                     credentials:#String = null,
                     notify-agents?:bool = true
                 }:void
    {if self._authenticated? != b? then
        set self._authenticated? = b?
        {if notify-agents? then
            {for agent in self.message-agents do
                {agent.set-authenticated? b?, credentials = credentials}
            }
        }
        || TODO: Fire a PropertyChangeEvent
    }
  }

  {method public {connect agent:#MessageAgent}:void
    {if-non-null agent then
        {if {self._message-agents.find agent} == -1 then
            {self._message-agents.append agent}
            {agent.internal-set-channel-set self}
            {if self.connected? then
                {agent.channel-connect-handler
                    {new ChannelEvent,
                        ChannelEvent.CONNECT,
                        channel = self.current-channel,
                        reconnecting? = false,
                        rejected? = false,
                        connected? = self.connected?
                    }
                }
            }
        }
    }
  }

  {method public {disconnect agent:MessageAgent}:void
    || FIXME: Should this send a synthetic disconnect event?
    def agent-index = {self._message-agents.find agent}
    {if agent-index >= 0 then
        {self._message-agents.remove agent-index}
        {self.disconnect-agent-helper agent}
    }
    {if self._message-agents.size == 0 and self.connected? then
        {self.disconnect-channel}
    }
  }
  {method private {disconnect-agent-helper agent:MessageAgent}:void
    || This will recurse, but this time the agent won't be found.
    || Should we really do both of these steps?
    {agent.disconnect}
    {agent.internal-set-channel-set null}
    {for i = self.pending-sends.size - 1 downto 0 do
        def ps = self.pending-sends[i]
        {if ps.agent == agent then
            {self.pending-sends.remove i}
            {if-non-null message = ps.message then
                {self.pending-messages.remove
                    message, error-if-missing? = false
                }
            }
        }
    }
    {agent.channel-disconnect-handler
        {ChannelEvent
            ChannelEvent.DISCONNECT,
            channel = self._current-channel,
            connected? = self.connected?
        }
    }
  }

  {method public {disconnect-all}:void
    || FIXME: Should this send synthetic disconnect events?
    def agents = {self._message-agents.clone}
    {self._message-agents.clear}
    {for agent in agents do
        || This will call disconnect, but the agent won't be found.
        {self.disconnect-agent-helper agent}
    }
    {if self.connected? then
        {self.disconnect-channel}
    }
  }

  {method public {login
                     username:#String,
                     password:#String,
                     charset:#String = null,
                     agent:#MessageAgent = null
                 }:void

    || Use legacy charset
    {if charset != null and
        {http-charset-to-char-encoding {non-null charset}} != CharEncoding.utf8
     then
        set charset = null
    }
    def creds = {encode-credentials
                    username, password, charset}

    {if-non-null agent then
        {agent.set-credentials creds, charset = charset}
     else
        {self.internal-login creds, charset = charset}
    }
  }
  
  {method private {internal-login
                      credentials:#String,
                      charset:#String = null
                  }:void
    {if self.authenticated? then
        || IllegalOperationError
        {error "Channel Set is already authenticated."}}
    
    {if self.auth-agent != null and
        self.auth-agent.state != AuthenticationAgent.LOGGED_OUT_STATE
     then
        || IllegalOperationError
        {error "ChannelSet is in the process of logging in or logging out."}
    }

    || Create CommandMessage for logging in.
    def cmd = {self.create-auth-message
                  CommandMessage.LOGIN_OPERATION,
                  credentials = credentials,
                  charset = charset
              }
    
    {if self.auth-agent == null then
        set self.auth-agent = {AuthenticationAgent self}}
    set self.auth-agent.state = AuthenticationAgent.LOGGING_IN_STATE
    {self.send {non-null self.auth-agent}, cmd}
  }
  
  {method public {logout agent:#MessageAgent = null}:void
    {if-non-null agent then
        set self.credentials = null
        {for ch in self.channels do
            {if-non-null ch then
                {ch.logout agent = agent}}}
     else
        {if self.auth-agent != null and
            (self.auth-agent.state == AuthenticationAgent.LOGGING_IN_STATE or
             self.auth-agent.state == AuthenticationAgent.LOGGING_OUT_STATE)
         then
            {error "ChannelSet is in the process of logging in or logging out."}
        }

        {self.sync-credentials null}
        def cmd = {self.create-auth-message
                      CommandMessage.LOGOUT_OPERATION}

        {if self.auth-agent == null then
            set self.auth-agent = {AuthenticationAgent self}}
        set self.auth-agent.state = AuthenticationAgent.LOGGING_OUT_STATE
        {self.send {non-null self.auth-agent}, cmd}
    }
  }

  {method protected {authenticate-succeeded
                        agent:AuthenticationAgent,
                        cmd:CommandMessage,
                        ack:AcknowledgeMessage
                    }:void
    def login? = (cmd.operation == CommandMessage.LOGIN_OPERATION)
    {if login? then
        {self.sync-credentials (cmd.body asa String)}
        set agent.state = AuthenticationAgent.LOGGED_IN_STATE
        set self.current-channel.authenticated? = true
     else
        set agent.state = AuthenticationAgent.SHUTDOWN_STATE
        set self.auth-agent = null
        {self.disconnect agent}

        set self.current-channel.authenticated? = false
    }
    || TODO: Notify
  }
  
  {method protected {authenticate-failed
                        agent:AuthenticationAgent,
                        cmd:CommandMessage,
                        err:ErrorMessage
                    }:void
    || TODO: Create Event

    set agent.state = AuthenticationAgent.SHUTDOWN_STATE
    set self.auth-agent = null
    {self.disconnect agent}

    || TODO: Notify
  }

  {method private {create-auth-message
                      operation:uint,
                      credentials:#String = null,
                      charset:#String = null
                  }:CommandMessage
    def cmd = {CommandMessage}
    set cmd.operation = operation
    set cmd.body = credentials
    set cmd.destination = "auth"
    {if-non-null charset then
        set cmd.headers[CommandMessage.CREDENTIALS_CHARSET_HEADER] = charset
    }
    {return cmd}
  }

  {method private {sync-credentials val:#String}:void
    set self.credentials = val

    || Set credentials to all MessageAgents
    {for ma in self.message-agents do
        set ma.credentials = val
    }

    || Set credentials to all Channels
    {for ch in self.channels do
        set ch.credentials = val
    }
  }
  
  {method public {send agent:MessageAgent, message:IMessage}:void
    {if self.connected? then
        || TODO: Clustering?
        {if-non-null self.current-channel then
            {self.current-channel.send agent, message}
        }
     else
        {if not {self.pending-messages.member? message} then
            {self.pending-messages.insert message}
            {self.pending-sends.append {new PendingSend, agent, message}}
        }
        {if not self.connecting? then
            {if self.current-channel == null or
                self.current-channel-index == -1
             then
                {self.hunt}
            }
            {type-switch self.current-channel
             case ccc:CurlConnectionChannel do
                || TODO: Flex has a special case for NetConnectionChannels that
                ||       accounts for some reconnection idyosyncrasies. For now,
                ||       we're just connecting the channel.
                {self.connect-channel}
             case n:Null do
                {return}
             else
                {self.connect-channel}
            }
        }
    }
  }

  {method private {hunt}:bool
    {if self.channels.empty? then
        {throw {new Exception, "NoChannelAvailableError"}}
    }
    {inc self.current-channel-index}
    {if self.current-channel-index >= self.channels.size then
        set self.current-channel-index = -1
        {return false}
    }
||--    {if self.current-channel-index > 0 then
||--        set self.hunting? = true
||--    }
    {if self.configured? then
        {if-non-null channel = self.channels[self.current-channel-index] then
            set self._current-channel = channel
         else
            || TODO: This implementation iterates over the channels, but the
            ||       Flex implementation does it differently. Figure out what's
            ||       different.
||--            {if-non-null channel-ids = self.channel-ids then
||--                {for id in channel-ids do
||--                    {if-non-null id then
||--                        set self.current-channel = {ServerConfig.get-channel id}
||--                        || TODO: Apply other channel properties found in the
||--                        ||       channel configuration (services-config.xml),
||--                        ||       such as <polling-enabled>.
||--                        {if-non-null self.current-channel then
||--                            {break}
||--                        }
||--                    }
||--                }
||--                {if-non-null c = self.current-channel then
||--                    {c.set-credentials self.credentials}
||--                    set self.channels[self.current-channel-index] = c
||--                 else
||--                    {throw {new Exception, "NoChannelAvailableError"}}
||--                }
||--             else
                {throw {new Exception, "NoChannelAvailableError"}}
||--            }
        }
     else
        set self._current-channel = self.channels[self.current-channel-index]
    }
    {return true}
  }

  {method public {set-credentials
                     credentials:#String,
                     agent:#MessageAgent = null,
                     charset:#String = null
                 }:void
    set self.credentials = credentials
    {for channel in self.channels do
        {channel.set-credentials
            self.credentials,
            agent = agent,
            charset = charset
        }
    }
  }

  {method public {add-channel channel:Channel}:void
    {if {self.channels.find channel} != -1 then
        {return}
    }
    {if self.configured? then
        {throw {new Exception, "Cannot add channels when configured."}}
    }
    {self.channels.append channel}
    {if-non-null self.credentials then
        {channel.set-credentials
            self.credentials,
            agent = null,
            charset = self.credentials-charset
        }
    }
  }

  {method public {remove-channel channel:Channel}:void
    {if self.configured? then
        {throw {new Exception, "Cannot remove channels when configured."}}
    }
    def channel-index = {self.channels.find channel}
    {if channel-index >= 0 then
        {self.channels.remove channel-index}
        {if channel == self.current-channel then
            {if self.connected? then
                {self.disconnect-channel}
            }
            set self._current-channel = null
            set self.current-channel-index = -1
        }
    }
  }

  {method protected {connect-channel}:void
    {if not self.connected? and not self.connecting? then
        set self.connecting? = true
        {self.current-channel.connect self}
        || FIXME: this needs to be removed when appropriate.
        {self.current-channel.add-event-handler self.channel-event-handler}
    }
  }
  {method protected {disconnect-channel}:void
    set self.connecting? = false
    {self.current-channel.remove-event-handler self.channel-event-handler}
    {self.current-channel.disconnect self}
  }

||--  {method protected {dispatch-rpc-event event:AbstractEvent}:void
||--    {event.call-token-responders}
||--    {self.enqueue-event event}
||--  }

  {method protected {message-handler event:MessageEvent}:void
    {self.enqueue-event event}
  }

  || Called by the current Channel.
  {method protected {channel-connect-handler e:ChannelEvent}:void
    set self.connecting? = false
    set self._connected? = true
    {while not self.pending-sends.empty? do
        def ps = self.pending-sends[0]
        {if-non-null m = ps.message then
            {self.pending-messages.remove m, error-if-missing? = false}
        }
        {type-switch ps.message
         case cm:CommandMessage do
            {if not ps.agent.config-requested? and
                ps.agent.needs-config? and
                cm.operation == CommandMessage.CLIENT_PING_OPERATION
             then
                set cm.headers[CommandMessage.NEEDS_CONFIG_HEADER] = true
                set ps.agent.config-requested? = true
            }
        }
        {if-non-null a = ps.agent then
            {if-non-null m = ps.message then
                {self.send a, m}
            }
        }
        {self.pending-sends.remove 0}
    }
    || TODO: Handle hunt
    || TODO: Refire, but why?
    {self.enqueue-event e}
    || TODO: Fire PropertyChangeEvent
  }

  || Called by the current Channel.
  {method protected {channel-disconnect-handler e:ChannelEvent}:void
    {dump "TODO: ChannelSet.channel-disconnect-handler"}
    || TODO:
  }

  {method protected {channel-fault-handler e:ChannelFaultEvent}:void
    {dump e.fault-code}
    {dump e.fault-string}
    {dump e.fault-detail}
    {dump "TODO: ChannelSet.channel-fault-handler"}
    || TODO: What should we be doing here?
    {if self.current-channel == e.channel then
        set self.connecting? = false
        set self._connected? = false
        || FIXME: What do we need to do to let hunting continue?
        set self._current-channel = null
    }
  }
}

{define-proc {encode-credentials
                 _username:#String,
                 _password:#String,
                 charset:#String
             }:#String
    {if _username == null and _password == null then
        {return null}
    }
    def username = {if-non-null val = _username then val else ""}
    def password = {if-non-null val = _password then val else ""}
    def credentials = username & ":" & password
    def bytes = {ByteArray}
    def encoding =
        {if-non-null charset then
            def charset-encoding = {http-charset-to-char-encoding charset}
            {if charset-encoding == CharEncoding.none-specified then
                CharEncoding.utf8
             else
                charset-encoding
            }
         else CharEncoding.utf8
        }
    {with-open-streams out =
        {TranscodingTextOutputStream
            {ByteArrayOutputStream bytes}, encoding, false}
     do
        {out.write-one-string credentials}}
    {return
        {base64-encode bytes}}
}
