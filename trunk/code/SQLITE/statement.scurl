||| Copyright (C) 1998-2007, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.
|||

|| prepared statement
|| --------------------
{doc-next
    {purpose
        Represents a prepared SQLite statement.
    }
    {notes
        Call {docref SQLiteDatabase.prepare} to construct this object.
    }
}
{define-class public open SQLiteStatement

  {doc-next
    {purpose
        The {docref SQLiteStatementHandle} that points to the prepared SQL
        statement in the memory.
    }
  }
  field package stmt:SQLiteStatementHandle

  {doc-next
    {purpose
        The SQL statment this object represents.
    }
  }
  field constant public sql:String

  {doc-next
    {purpose
        The {docref SQLiteDatabase} this object was constructed for.
    }
  }
  field constant public database:SQLiteDatabase

  {doc-next
    {purpose
        Table that has the association of the column index to the
        value it is bind to.
    }
    {notes
        If non-{ctext null}, it contains a list of column indexes with
        the corresponding values it is bound to.
        
        This is populated when the bind methods are called for this
        statement. It is used when the statement is recompiled after
        it has been finalized.
    }
  }
  field package _bind-table:#{HashTable-of int, any}

  {doc-next
    {purpose
        Construct a {docref SQLiteStatement} object.
    }
    {parameter database,
        The {docref SQLiteDatabase} this statemet is associated with.
    }
    {parameter sql,
        The SQL statemet this object represents.
    }
    {notes
        The {param sql} statement will not be compiled till it is
        needed.
    }
  }
  || TODO: Should this be "protected" and people should just use
  || SQLiteDatabase.create-statement?
  {constructor public {default 
                           database:SQLiteDatabase, 
                           sql:String
                       }
    set self.database = database
    set self.sql = sql
  }

  {doc-next
    {purpose
        Returns a pointer to the compiled sql statement.
    }
    {notes
        This getter will always return a compiled {docref
        SQLiteStatement.sql} statement. If the statement was not
        compiled or finalized, it will re-compile it.

        Call {docref SQLiteStatement.stmt} if you do not wnat to
        recompile the statement.
    }
  }
  {getter private {non-null-stmt}:SQLiteStatementHandle
    || Calling prepare is a no-op if the statement is already
    || compiled.
    {self.prepare}
    {return self.stmt}
  }

  {getter public {bind-table}:{HashTable-of int, any}
    {return
        {if-non-null bind-table = self._bind-table then
            bind-table
         else
            let constant bind-table:{HashTable-of int, any} =
                {{HashTable-of int, any}}
            set self._bind-table = bind-table
            bind-table
        }
    }
  }

  {doc-next
    {purpose
        Compiles {docref SQLiteStatement.sql} into a byte-code program
        readable by the SQLite virtual machine.
    }
    {notes
        This method is a no-op if {ctext SQLiteStatement.stmt} is a
        valid, i.e. not 0.

        This method is called lazily to compile the SQL statement if
        it is not compiled or had been previously finalized. This is
        called by {docref SQLiteStatement.non-null-stmt} getter if
        {docref SQLiteStatement.stmt} is 0.
        
        This method will also bind all the columns with their
        respective values as stored in the {docref
        SQLiteStatement.bind-table}.

        If the compilation fails an appropriate {docref
        SQLiteException} will be thrown.
    }
  }
  {method public {prepare}:void
    {if self.stmt != 0 then {return}}

    {self.database.prepare-statement self}

    {if-non-null table = self._bind-table then
        {for val key i in table do
            {self.bind-any i, val}
        }
    }
  }
  
  {doc-next
    {purpose
        Executes the {docref SQLiteStatement}.
    }
    {return-vals
        The return value is either {ctext SQLiteStatus.BUSY}, {ctext
        SQLiteStatus.DONE}, {ctext SQLiteStatus.ROW}, {ctext
        SQLiteStatus.ERROR} or {ctext SQLiteStatus.MISUSE}.

        {ctext SQLiteStatus.DONE} means that this statement has finished
        executing successfully. {ctext SQLiteInterface.step} should
        not be called again on this object without calling {docref
        SQLiteStatement.reset}.

        If this SQL statement being executed returns any data, then
        {ctext SQLiteStatus.ROW} is returned for each time a row of data is
        ready for processing by the caller. The values can be accessed
        by using {docref SQLiteSatement.get-column} method. Subsequent
        rows are retrieved by calling {ctext SQLiteStatement.step}
        method.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {step}:SQLiteStatus
    {return {{SQLiteInterface}.step self.non-null-stmt}}
  }

  {doc-next
    {purpose
        Returns the number of values in the current row of the result
        set.
    }
    {return-vals
        If called before {docref SQLiteStatement.step} or after {ctext
        SQLiteStatement.step} has returned a value that is not {ctext
        SQLiteStatus.ROW}, the return value is zero. Otherwise it is
        the number of values in the current row of the result set.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {getter public open {data-count}:int
    {return {{SQLiteInterface}.data-count self.non-null-stmt}}
  }

  {doc-next
    {purpose
        Returns the number of columns in the result set.
    }
    {return-vals
        Returns the number of columns in the result set. It is zero if
        this {docref SQLiteStatement} represents an SQL statement that
        does not return data.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {getter public open {column-count}:int
    {return {{SQLiteInterface}.column-count self.non-null-stmt}}
  }

  {doc-next
    {purpose
        The name of a column in this {docref SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column name is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The column name.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-name icol:int}:String
    {return {{SQLiteInterface}.column-name self.non-null-stmt, icol}}
  }

  {getter public open {column-names}:StringArray
    let constant column-name-count:int = self.column-count
    let constant column-names:StringArray =
        {StringArray efficient-size = column-name-count}
    {for i = 0 below column-name-count do
        {column-names.append {self.get-column-name i}}
    }
    {return column-names}
  }

  {doc-next
    {purpose
        The storage class of a column in this {docref
        SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column type is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        Returns the storage class of a given column with ordinal
        {param icol} in the result set obtained for this object.

        See also {docref SQLiteInterface.column}.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-type icol:int}:SQLiteDatatype
    {return 
        {{SQLiteInterface}.column-type self.non-null-stmt, icol}
    }
  }

  {doc-next
    {purpose
        The declared type of a column in this {docref SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column declared type is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        Returns the declared type of a column, as it is defined in the
        {ctext CREATE TABLE} statement in the database.

        If the column does not correspond to an actual table column
        {ctext null} is returned.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-decltype icol:int}:#String
    {return {{SQLiteInterface}.column-decltype self.non-null-stmt, icol}}
  }

  {doc-next
    {purpose
        Returns information about the value, as a int, in a single
        column of the current row in a result set of this {docref
        SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column value is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The value of the column as a int.
    }
    {notes
        If this {ctext SQLiteStatement} is currently not pointing to a
        valid row, or if the column index is out of range, the result
        is undefined.

        If the item is {ctext null} in the table, you will get a
        0. In order to distinguish between a {ctext null} value or a
        value with 0 one can use {docref SQLiteStatement.column-type}.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-int icol:int}:int
    {return {{SQLiteInterface}.column-int self.non-null-stmt, icol}}
  }

  {doc-next
    {purpose
        Returns information about the value, as a int64, in a single
        column of the current row in a result set of this {docref
        SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column value is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The value of the column as a int64.
    }
    {notes
        If this {docref SQLiteStatement} is currently not pointing to
        a valid row, or if the column index is out of range, the
        result is undefined.

        If the item is {ctext null} in the table, you will get a
        0. Inorder to distinguish between a {ctext null} value or a
        value with 0 one can use {docref SQLiteStatement.column-type}.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-int64 icol:int}:int64
    {return {{SQLiteInterface}.column-int64 self.non-null-stmt, icol}}
  }

  {doc-next
    {purpose
        Returns information about the value, as a double, in a single
        column of the current row in a result set of this {docref
        SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column value is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The value of the column as a double.
    }
    {notes
        If this {ctext SQLiteStatement} is currently not pointing to a
        valid row, or if the column index is out of range, the result
        is undefined.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-double icol:int}:double
    {return {{SQLiteInterface}.column-double self.non-null-stmt, icol}}
  }

  {doc-next
    {purpose
        Returns information about the value, as a {docref String}, in
        a single column of the current row in a result set of this
        {docref SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column value is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The value of the column as a {ctext String}.
    }
    {notes
        If this {docref SQLiteStatement} is currently not pointing to a valid
        row, or if the column index is out of range, the result is
        undefined.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-text icol:int}:String
    {return {{SQLiteInterface}.column-text self.non-null-stmt, icol}}
  }

  {doc-next
    {purpose
        Returns information about the value, as a chunck of memory
        data, in a single column of the current row in a result set of
        this {docref SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column value is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The value of the column as a chunk of data in memory.
    }
    {notes
        If this {ctext SQLiteStatement} is currently not pointing to a
        valid row, or if the column index is out of range, the result
        is undefined.

        One can use {docref SQLiteStatement.column-bytes} to get the
        number of bytes in the {ctext blob}.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-blob
                          icol:int, out:ByteArray = {ByteArray}
                      }:ByteArray
    {return {{SQLiteInterface}.column-blob self.non-null-stmt, icol, out = out}}
  }

  {doc-next
    {purpose
        Returns the number of bytes it will take the column value in
        the memory, in a single column of the current row in a result
        set of this {docref SQLiteStatement}.
    }
    {parameter icol,
        The column ordinal for which the column value is to be
        retrieved. The column index is zero-based.
    }
    {return-vals
        The number of bytes that will be taken in the memory to store
        the column value.
    }
    {notes
        If this {ctext SQLiteStatement} is currently not pointing to a
        valid row, or if the column index is out of range, the result
        is undefined.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-column-bytes icol:int}:int
    {return {{SQLiteInterface}.column-bytes self.non-null-stmt, icol}}
  }

  {method public {get-column-value index:int}:any
    let t:SQLiteDatatype = {self.get-column-type index}
    {return
        {switch t
         case SQLiteDatatype.INTEGER do
            || TODO: is there a better way?
            let xi:int64 = {self.get-column-int64 index}
            {if xi <= max-int32 and xi >= min-int32 then
                xi asa int
             else xi}
         case SQLiteDatatype.FLOAT do {self.get-column-double index}
         case SQLiteDatatype.TEXT do {self.get-column-text index}
         case SQLiteDatatype.NULL do null
         case SQLiteDatatype.BLOB do
            || TODO: test this
            {self.get-column-blob index}
         else {error {message Unexpected SQLite datatype {value t}}}
        }
    }
  }

  {doc-next
    {purpose
        Return the column values in the current row of this statement.
    }
    {return-vals
        The column values.

        These will be undefined if there is no current row.
    }
  }

  {getter public {current-row}:Array
    || TODO: consider data-count
    || - zero if no current row
    let nval:int = self.column-count
    let row:Array = {Array efficient-size = nval}
    {for i = 0 below nval do
        {row.append {self.get-column-value i}}
    }
    {return row}
  }

  || TODO: docstring
  {method public {rows-to-Iterator}:{Iterator-of Array}
    {self.reset}
    {return {SQLiteStatementRowsIterator self}}
  }

  || SQL convenience functions
  || --------------------
  
  {doc-next
    {purpose
        Return whether this statement contains any data.
    }
    {return-vals
        If any rows are selected by the statement, returns {ctext true}.
    }
  }

  {method public {data-exists?}:bool
    {self.reset}
    def status = {self.step}
    def exists? = 
        {switch status
         case SQLiteStatus.ROW do true
         case SQLiteStatus.DONE do false
         else
            {self.database.check-status}
            {unreachable}
        }
    {self.reset}
    {return exists?}
  }
  
  {doc-next
    {purpose
        Return one value from the first row of this statement.
        {parameter index, specifies which column.}
    }
    {return-vals
        The value of the specifed column for the first row,
        or null if no rows are selected by the statement.
    }
  }

  {method public {data-value index:int = 0}:any
    {self.reset}
    def status = {self.step}
    def val = 
        {switch status
         case SQLiteStatus.ROW do
            {self.get-column-value index}
         case SQLiteStatus.DONE do
            null
         else
            {self.database.check-status}
            {unreachable}
        }
    {self.reset}
    {return val}
  }

  {doc-next
    {purpose
        Return the values in the first row of this statement.
    }
    {return-vals
        An array of values.

        These will be undefined if there is no current row.
    }
  }

  {method public {data-row}:Array
    {self.reset}
    def status = {self.step}
    def row:Array =
        {switch status
         case SQLiteStatus.DONE, SQLiteStatus.ROW do
            self.current-row
         else
            {self.database.check-status}
            {unreachable}
        }
    {self.reset}
    {return row}
  }

  {doc-next
    {purpose
        Return the values in each row of this statement.
    }
    {return-vals
        An array of 
  {method public {data-rows}:{Array-of Array}
    let constant rows:{Array-of Array} = {{Array-of Array}}
    {self.reset}
    {while true do
        {switch {self.step}
         case SQLiteStatus.OK do
            {break}
         case SQLiteStatus.DONE do
            {break}
         case SQLiteStatus.ROW do
            {rows.append self.current-row}
         else
            || signal exception
            {self.database.check-status}
        }
    }
    {self.reset}
    {return rows}
  }

  {doc-next
    {purpose
        Return the values in a column of this statement.
    }
    {return-vals
        An array of values.
    }
  }

  {method public {data-column index:int = 0}:Array
    let constant col:Array = {Array}
    {self.reset}
    {while true do
        {switch {self.step}
         case SQLiteStatus.OK do
            {break}
         case SQLiteStatus.DONE do
            {break}
         case SQLiteStatus.ROW do
            {col.append {self.get-column-value index}}
         else
            || signal exception
            {self.database.check-status}
        }
    }
    {self.reset}
    {return col}
  }

  || ==========


  {doc-next
    {purpose
        Deletes this prepared SQL statement.
    }
    {notes
        All prepared statements must be finalized before calling
        {docref SQLiteDatabase.close}, otherwise {ctext
        SQLiteDatabase.close} will fail and return {ctext
        SQLiteStatus.BUSY}.

        This function can be called at any point during the execution
        of the virtual machine. If the virtual machine has not
        completed execution when this routine is called, it is like
        encountring an error or an interrupt. In this case, incomplete
        updates may be rolled back and transactions cancelled,
        depending on the circumtances, and {ctext
        SQLiteStatement.finalize} will return {ctext
        SQLiteStatus.ABORT}.

        It is a no-op to call this method if this object is already
        finalized and not re-compiled.
    }
  }
|| TODO: will return same status code as most recent step call.
  {method public open {finalize}:SQLiteStatus
    {if self.stmt == 0 then {return SQLiteStatus.OK}}

    let constant status:SQLiteStatus = {self.database.finalize-statement self}
    set self.stmt = 0
    {return status}
  }

  {doc-next
    {purpose
        Resets the {docref SQLiteStatement}.
    }
    {notes
        After this call this {ctext SQLiteStatement} is ready to be
        re-executed. Any SQL parameters that have values bound to them
        will retain their values on the subsequent execution.
    }
    {notes
        If the {ctext SQLiteStatement} is not yet prepared or it is
        finalized then this method is a no-op and returns {ctext
        SQLiteStatement.OK}.
    }
  }
|| TODO: will return same status code as most recent step call.
  {method public open {reset}:SQLiteStatus
    {if self.stmt == 0 then {return SQLiteStatus.OK}}

    {return {{SQLiteInterface}.reset self.stmt}}
  }

  || TODO: docstring
  {method public open {clear-bindings}:void
    {if self.stmt == 0 then {return}}
    
    {if {{SQLiteInterface}.clear-bindings self.stmt} != SQLiteStatus.OK then
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Assigns (or binds) an int to a parameter in this prepared SQL
        statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {parameter val,
        The value to bind to the parameter with the index {param index}.
    }
    {notes
        Unbound parameters are interpreted as NULL.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.

        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public open {bind-int index:int, val:int}:void
    let constant status:SQLiteStatus =
        {{SQLiteInterface}.bind-int self.non-null-stmt, index, val}
    
    {if status == SQLiteStatus.OK then
        set self.bind-table[index] = val
     else
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Assigns (or binds) an int64 to a parameter in this prepared SQL
        statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {parameter val,
        The value to bind to the parameter with the index {param index}.
    }
    {notes
        Unbound parameters are interpreted as NULL.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
        
        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public open {bind-int64 index:int, val:int64}:void
    let constant status:SQLiteStatus =
        {{SQLiteInterface}.bind-int64 self.non-null-stmt, index, val}
    
    {if status == SQLiteStatus.OK then
        set self.bind-table[index] = val
     else
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Assigns (or binds) a double to a parameter in this prepared
        SQL statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {parameter val,
        The value to bind to the parameter with the index {param index}.
    }
    {notes
        Unbound parameters are interpreted as NULL.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.

        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public open {bind-double index:int, val:double}:void
    let constant status:SQLiteStatus =
        {{SQLiteInterface}.bind-double self.non-null-stmt, index, val}

    {if status == SQLiteStatus.OK then
        set self.bind-table[index] = val
     else
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Assigns (or binds) a {ctext null} value to a parameter in this
        prepared SQL statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.

        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public open {bind-null index:int}:void
    let constant status:SQLiteStatus =
        {{SQLiteInterface}.bind-null self.non-null-stmt, index}

    {if status == SQLiteStatus.OK then
        set self.bind-table[index] = null
     else
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Assigns (or binds) a {docref String} value to a parameter in this
        prepared SQL statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {parameter val,
        The value to bind to the parameter with the index {param
        index}.
    }
    {notes
        Unbound parameters are interpreted as NULL.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.

        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public open {bind-text index:int, val:String}:void
    let constant status:SQLiteStatus =
        {{SQLiteInterface}.bind-text self.non-null-stmt, index, val}

    {if status == SQLiteStatus.OK then
        set self.bind-table[index] = val
     else
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Assigns (or binds) a chunk of data in memory to a parameter in
        this prepared SQL statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {parameter val,
        The value to bind to the parameter with the index {param
        index}.
    }
    {notes
        Unbound parameters are interpreted as NULL.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.

        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public open {bind-blob index:int, val:ByteArray}:void
    let constant status:SQLiteStatus =
        {{SQLiteInterface}.bind-blob self.non-null-stmt, index, val}

    {if status == SQLiteStatus.OK then
        set self.bind-table[index] = {val.clone}
     else
        {self.database.check-status}
    }
  }

  {doc-next
    {purpose
        Number of parameters in this precompiled statement.
    }
    {return-vals
        The number of parameters.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {getter public open {bind-parameter-count}:int
    {return {{SQLiteInterface}.bind-parameter-count self.non-null-stmt}}
  }

  {doc-next
    {purpose
        The name of a parameter in this precompiled statement.
    }
    {parameter index,
        Index of the parameter whose name is to be retrieved. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {return-vals
        The name of the parameter at {param index} in this precompiled
        statement.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-bind-parameter-name index:int}:String
    {return {{SQLiteInterface}.bind-parameter-name self.non-null-stmt, index}}
  }
  
  {doc-next
    {purpose
        The index of the parameter in this precompiled statement.
    }
    {parameter name,
        The name of the parameter whose index is requested.
    }
    {return-vals
        The index of the parameter with the given name.

        The name must match exactly. If there is no parameter with the
        given name, this method returns 0.
    }
    {notes
        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
    }
  }
  {method public open {get-bind-parameter-index name:String}:int
    {return {{SQLiteInterface}.bind-parameter-index self.non-null-stmt, name}}
  }    

  {doc-next
    {purpose
        Assigns (or binds) a value to a parameter in this prepared SQL
        statement.
    }
    {parameter index,
        Index of the parameter to be set. 

        All parameters are identified by an index or a
        number. Positional parameters, for example, are numbered using
        sequential integer values, starting with 1 for the first
        parameter.
    }
    {parameter val,
        The value to bind to the parameter with the index {param index}.
    }
    {notes
        Unbound parameters are interpreted as NULL.

        If {docref SQLiteStatement.sql} is not compiled or was
        finalized, it will be compiled to get the byte code.
        
        If the binding operation is successful, the {docref
        SQLiteStatement.bind-table} will be updated to reflect this
        binding so that this binding can be re-applied if this
        statement is recompiled in the future.
    }
  }
  {method public {bind-any index:int, val:any}:void
    let constant interface:SQLiteInterface = {SQLiteInterface}
    let constant stmt:SQLiteStatementHandle = self.non-null-stmt
    let constant status:SQLiteStatus =
        {type-switch val
         case x:String do
            {interface.bind-text stmt, index, x}
         case x:int do
            {interface.bind-int stmt, index, x}
         case x:int64 do
            {interface.bind-int64 stmt, index, x}
         case x:double do
            {interface.bind-double stmt, index, x}
         case x:Null do
            {interface.bind-null stmt, index}
         case x:ByteArray do
            {interface.bind-blob stmt, index, x}
         else
            {error "Unexpected type: ", {type-of val}}
        }

    {if status != SQLiteStatus.OK then
        {self.database.check-status}
    }
  }
  
  {doc-next
    {purpose
        Binds statement parameters to supplied arguments.
    }
    {parameter ...,
        The values will be bound to the index (starting at 1) that
        they appear at in the argument list.
    }
  }
  {method public {bind ...:any}:void
    let constant database:SQLiteDatabase = self.database
    let i:int = 1
    {for value in ... do
        {self.bind-any i, value}
        {inc i}
    }
    let nval:int = self.bind-parameter-count
    {while i <= nval do
        {self.bind-null i}
        {inc i}
    }
  }
  
  {define-proc private {sql-insert-for table:String, ncol:int}:String
    let buf:StringBuf = {StringBuf "INSERT INTO "}
    {buf.concat table}
    {buf.concat "\n VALUES ("}
    {for i = 0 below ncol do
        {if i > 0 then {buf.concat ", "}}
        {buf.concat "?"}
    }
    {buf.concat ");\n"}
    {return {buf.to-String}}
  }

  {define-proc private {insert-statement-for
                           database:SQLiteDatabase,
                           table:String
                       }:SQLiteStatement
    let ncols:int = 
        {with-statement in database
            stmt = {format "SELECT * from %s LIMIT 0", table}
         do
            stmt.column-count
        }
    let sql:String = {SQLiteStatement.sql-insert-for table, ncols}
    {return {database.create-statement sql}}
  }

  {doc-next
    {purpose
        Returns a procedure that can be used to insert rows
        into the specified table.
    }
    {parameter table,
        The table.
    }
    {return-vals
        A procedure that inserts a row into the table,
        given a {ctext StringArray} containing column values.
    }
  }
  {define-proc public {insert-proc 
                          database:SQLiteDatabase,
                          table:String
                      }:({proc-type {...:any}:SQLiteStatus}, SQLiteStatement)
    let statement:SQLiteStatement = 
        {SQLiteStatement.insert-statement-for database, table}
    {return
        {proc {...:any}:SQLiteStatus
            {statement.bind ...}
            || execute
            let constant status:SQLiteStatus = {statement.step}
            {statement.reset}
            {return status}
        },
        statement
    }
  }
  {doc-next
    {purpose
        Import CSV data into the specified table.
    }
    {parameter table,
        The table.
    }
    {parameter loc,
        The CSV file.
    }
    {parameter ...,
        The rest args are suppliced to {docref CsvDataReader}.
    }
  }
  {define-proc public {import-csv
                          database:SQLiteDatabase,
                          table:String,
                          loc:Url, ...
                      }:void
    let (f:{proc-type {...:any}:SQLiteStatus}, statement:SQLiteStatement) =
        {SQLiteStatement.insert-proc database, table}
    {try
        {with-open-streams
            in:CsvDataReader = {CsvDataReader loc, {splice ...}}
         do
            {with-transaction in database immediate do
                {while true do
                    {if-non-null xs = {in.read-record} then
                        let constant status:SQLiteStatus = {f {splice xs}}
                        {switch status
                         case SQLiteStatus.OK,
                             SQLiteStatus.DONE do
                            || success
                         else 
                            || NOTE: consider collect and return failed records
                            || BETTER: use ON CONFLICT clause, per keyword arg
                            {database.check-status}
                        }
                     else {break}
                    }
                }
            }
        }
     finally
        {statement.finalize}
    }
  }
}

{define-class package SQLiteStatementRowsIterator
  {inherits {Iterator-of Array}}

  field private constant stmt:SQLiteStatement

  {constructor package {default stmt:SQLiteStatement}
    set self.stmt = stmt
  }

  {method public {reset}:void
    {self.stmt.reset}
  }

  {method public {read-one}:(val:Array, eof?:bool)
    {switch {self.stmt.step}
     case SQLiteStatus.OK, SQLiteStatus.DONE do
     case SQLiteStatus.ROW do
        {return self.stmt.current-row, false}
     else
        {self.stmt.database.check-status}
    }
    {return {uninitialized-value-for-type Array}, true}
  }

}
