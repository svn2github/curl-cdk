||| Copyright (C) 1998-2007, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{curl 6.0 applet}

{applet manifest = "manifest.mcurl", locale = "en"}

{include "../utils/guide-header.scurl"}
{include "../utils/support.scurl"}

{chapter
    index= {HeadingIndex primary-key="SQLite Databases"},
    SQLite Overview
}

|| ====================
{heading level=2,
    SQLITE Overview
}
{summary
    {itemize
        {item Use {ctext SQLiteDatabase} to organize data.}
        {item Use {ctext SQLiteStatement} for queries.}
        {item Use {ctext SQLiteRecordSet} to present and manipulate query results in Curl.}
    }
}
{paragraph
    The Curl Data Kit package {docref COM.CURL.CDK.SQLITE}
    allows you to build applications that make use of local SQL databases,
    using the popular {link href = {url "http://www.sqlite.org"}, SQLite}
    SQL engine.

    This allows data centric Curl applications to take advantage of the
    full power of the SQL language (joins, indexes, transactions, triggers, constraints, etc).

    SQLite databases are fully integrated with Curl {docref COM.CURL.DATA-ACCESS} package:
    query results are represented using {docref SQLiteRecordSet} subclasses,
    so standard Curl techniques to present and manipulate data can be used
    (like {docref RecordView}, {docref RecordGrid}, {docref RecordForm} and {docref DataBinding}).
}

|| ====================
{heading level=3,
   Databases
}
{paragraph
    SQLite databases are self-contained files.
    
    Use {docref SQLiteDatabase} to create or read a database.
    
    {itemize
        {item specify the {ctext Url} of the database file.}
        {item The specified database file will be opened.}
        {item If the specified file does not exist, it will be created.}
        {item To create an "in-memory" database, supply {ctext null}.}
        {item SQLite database files use the local filesystem.}
        {item If an {monospace http} location is specified,
            its contents will be copied to {monospace curl://user-data/}.}
    }

    Use {docref SQLiteDatabase.execute} to perform SQL operations.

    {code-box 
        || NOTE: curl-code display is problematic with left "outdent"
        || - code must be flush left for applet to display properly.
        || - don't let the IDE indent the "db.execute" line
        {curl-code
{db.execute "
CREATE TABLE products (
  id TEXT NOT NULL PRIMARY KEY,
  name TEXT NOT NULL,
  price DOUBLE NOT NULL);"}}}

    Use {ctext sql-} methods to obtain data. They take a SQL expression,
    and optional parameters, and return the result.

    {itemize
        {item {docref-abbr SQLiteDatabase.sql-value} returns a single value.
            {curl-code {db.sql-value "SELECT AVG(price) FROM products"}}}
        {item {docref-abbr SQLiteDatabase.sql-row} returns the values from a row.
            {curl-code {db.sql-row "SELECT * FROM products WHERE id = ?", "0001"}}}
        {item {docref-abbr SQLiteDatabase.sql-rows} returns the values from all the rows.
            {curl-code {db.sql-rows "SELECT * FROM products"}}}
        {item {docref-abbr SQLiteDatabase.sql-column} returns the values from a column.
            {curl-code {db.sql-column  "SELECT name FROM products WHERE price > ?", 10}}}
        {item {docref-abbr SQLiteDatabase.sql-exists?} returns whether any rows were selected.
            {curl-code {db.sql-exists? "SELECT * FROM products WHERE name LIKE 'p%'"}}}
    }

    {privilege-note}

    {x-example-ref title = "Create database",
        {url "examples/create-database.curl"}}

    The {docref SQLiteDatabase} object manages all resources associated with database access.
    Databases will be closed, and resources released, whenever a Curl applet is suspended,
    and reactivated when it is resumed, so no bookkeeping is needed in the application itself.

    Any database errors are signaled using {docref SQLiteException}.
    This includes the SQLite error code, and explanatory message.
    When you need several database operations to be treated atomically,
    you can use a transaction (starting with SQL {monospace BEGIN},
    and ending with SQL {monospace COMMIT} or SQL {monospace ROLLBACK}).
    The {docref with-transaction} syntax is a convenient way to specify a transaction.

    {code-box 
        {curl-code
            {with-transaction in db do
                {db.execute
                    "INSERT INTO products VALUES ('0008', 'notebook', 9.00)"}
                {db.execute
                    "INSERT INTO products VALUES ('0009', 'paperclips', 2.75);"}
            }}}

}

|| ====================
{heading level=3,
   Statements
}
{paragraph    
    Use {docref SQLiteStatement}s to encapsulate SQL operations.
    There are several advantages to using prepared statements.

    {itemize
        {item modularity - SQL can be isolated from other code}
        {item efficiency - SQL compiles statements into byte code before execution.
            When statements are reused, the overhead of parsing and compiling is avoided.}
        {item security - using parameters protects statements from "SQL injection" attacks}
    }

    Use {docref SQLiteDatabase.create-statement} or {docref SQLiteStatement}
    to create an SQL statement object.

    Statements can be defined with variable parameters,
    which can be supplied by the caller.

    A statement, once prepared (or {docref-abbr SQLiteStatement.reset}),
    is essentially a cursor on the query results.

    Use {docref-abbr SQLiteStatement.step} to obtain each data row.
    The {ctext step} return value indicates the kind of result.
    {itemize
        {item {docref SQLiteStatus}.ROW indicates that a data row is available.}
        {item {docref SQLiteStatus}.DONE indicates that  no further data is available.}
        {item Other {docref SQLiteStatus} codes indicate error conditions.}
    }

    Use high level {ctext data-} methods for consolidated results.
    Use {docref-abbr SQLiteStatement.rows-to-Iterator} to iterate on rows.
    Lower level {ctext get-} methods can be used to obtain individual data items.

    This is the "life cycle" of a statement.
    {itemize
        {item create with {docref SQLiteDatabase.create-statement}.}
        {item specify parameters with {docref-abbr SQLiteStatement.bind} and other {ctext bind-} methods.}
        {item execute with {docref-abbr SQLiteStatement.step}.}
        {item obtain data with {docref-abbr SQLiteStatement.get-column-value} and other {ctext get-column-} methods.}
        {item reset for further use with {docref-abbr SQLiteStatement.reset}.
            Note that parameter bindings are retained when a statement is reset.
            Use {docref-abbr SQLiteStatement.clear-bindings} to unset bound parameters.}
        {item dispose with {docref-abbr SQLiteStatement.finalize}.
            Every statement will eventually be finalized, and its resources released,
            when the database is closed, or when the applet is suspended.
            You can use the {docref with-statement} syntax to ensure that
            a statement is immediately finalized.}
    }

    {x-example-ref title = {message Statement with iterator},
        {url "examples/statement-iterator.curl"}
    }
    
    {x-example-ref title = {message Statement with step},
        {url "examples/statement-step.curl"}
    }
    
    {x-example-ref title = {message Statements with step}, 
        {url "examples/statements.curl"}
    }

    Parameterized statements are also useful for creation and update operations.
    For example, a statement can be used for inserting rows into a table
    
    {code-box
        {curl-code
            def insert =
                {db.create-statement
                    "INSERT INTO log (when, where, what) VALUES (?, ?, ?)"}
            {insert.reset}
            {insert.bind "now", "here", "this"}
            {insert.step}
        }}
    
    {x-example-ref title = {message Statement for insert},
        {url "examples/statement-insert.curl"}
    }

    In fact, there are predefined functions for bulk data insertion
    that use that technique.
    
    {itemize
        {item {docref SQLiteStatement.insert-proc}
            returns an insertion procedure for a specified table.}
        {item {docref SQLiteStatement.import-csv}
            inserts rows into a specified table from a CSV file.}
    }

    This example uses boston temperature data in CSV format
    (also used in {link href = {dguide.merge "charts.curl"}, Charts chapter})
    to compute annual summary informetion ussing SQL.
    
    {x-example-ref title = {message Bulk insertion},
        {url "examples/import-csv.curl"}
    }
}

|| TODO: datatypes

|| ====================
{heading level=3,
   RecordSets
}
{paragraph    
    You can combine the power of SQL for data manipulation
    with that of Curl for application logic and GUI.

    The standard Curl{registered-trademark}
    {link href = {dguide.merge "data-access.curl"}, Data Access}
    packages provide for representation and display of
    data organized in records and fields,
    using {docref RecordSet}, {docref RecordView} and related classes.

    Any SQLite query can be used to create an {docref SQLiteBasicRecordSet}.

    The standard Curl {link href = {dguide.merge "data-connection.curl"}, Connected Data} package
    provides a generic mechanism to connect with an external data source.

    Use {docref SQLiteConnection} to apply that API to SQLite databases.
}

{Frame background = "pink", margin = 6px,
    {paragraph {bold TODO:}
        Describe modifiability variants,
        after update behavior finalized.}
}
{itemize
    {item table recordsets}
    {item view recordsets}
    {item query recordsets}
}

{x-example-ref title = {message Create RecordSet},
    {url "recordset-create.curl"}
}

{x-example-ref title = {message RecordSet with Form},
    {url "recordset-form.curl"}
}

{x-example-ref title = {message RecordSet with Chart},
    {url "recordset-chart.curl"}
}

{paragraph
    Some kinds of processing can performed either
    at the level of the database engine (in SQL),
    or at the level of the application (in Curl).
    It can be confusing when similar processing is specified at both levels.
    
    In general, it is preferable to rely on the database layer
    for data-centric processing.  
}

{itemize
    {item {bold sort/filter criteria} 
        These can be specified with {docref RecordView.sort} and {docref RecordView.filter},
        and are used by {docref RecordGrid} and {docref RecordSetdisplay} subclasses.
        SQL queries offer powerful facilities for sorting and filtering.

        || RV shadows SQL
    }
    {item {bold commit/revert}
        These methods allow for provisional RecordSet changes,
        and are useful to manage operations from a GUI form.
                
        SQL transactions (bounded by {monospace BEGIN}
        and {monospace COMMIT} or {monospace ROLLBACK}) allow
        compound operations to be performed atomically.

        || RS
        || good practice: "early commit" from Curl - every mod or every record
    }
    {item {bold constraints}
        Certain constraints ({docref RecordField.nullable?} and
        {docref RecordField.index-type}) are enforced by {ctext RecordSet}s.

        SQL offers powerful facilities for enforcing these (and other) constraints.

        With {ctext SQLiteRecordSet}s, constraints are enforced by SQLite, not by Curl.
    }
    {item {bold database selection}
        The generic {docref Connection} API allows for more than one database
        to be accessed through a connection, as is typical in a server side DBMS.
        Therefore, {ctext database-name} is a significant parameter or return value.

        SQLite databases are single files, so the {ctext database-name} parameter is not meaningful.
        However, using the SQL extensions {ctext ATTACH} and {ctext DETACH}, more than
        one database can be active through a single SQLite database.
    }
}

{x-example-ref title = {message Attach Database},
    {url "attach.curl"}
}

|| ====================
{heading level=3,
   Feedback
}
{paragraph
    The SQLite engine allows for application to be notified of changes,
    by registration of callbacks.  These notification mechanisms
    are exposed by {docref SQLiteDatabase} using {docref SQLiteEvent} subclasses.
}

{itemize
    {item {bold progress handler}
        Use {docref SQLiteDatabase.set-progress-handler}
        to get periodic calls to a function
        during long-running SQL operations.
    }
    {item {bold busy handler}
        When more than one process might access the same database concurrently,
        the SQLite engine uses locking to prevent inconsistent changes.
        Attempts by an application to perform an operation which is locked
        will get a {docref SQLiteStatus}.{ctext BUSY} result,
        which, by default, will be thrown as an exception.
        Use {docref SQLiteDatabase.busy-timeout}
        (or the more advanced {docref SQLiteDatabase.set-busy-handler})
        to control behavior for this condition.
    }
    {item {bold update notification}
        The application can observe changes by adding event handlers
        for these actions.
        {itemize
            {item {docref SQLiteUpdate} when a row is modified.}
            {item {docref SQLiteCommit} before SQL {ctext COMMIT}.}
            {item {docref SQLiteRollback} after SQL {ctext REVERT}.}
        }
    }
}

{Frame background = "pink", margin = 6px,
    {italic {bold TODO:}
        Confirm how these are specified and enabled,
        after migration from old Connection is finalized.}
}

{x-example-ref title = {message progress Notification},
    {url "progress.curl"}
}

{x-example-ref title = {message Busy Handler},
    {url "busy-handler.curl"}
}

|| ====================
{heading level=3,
   Extension
}
{paragraph
    The SQLite engine allows for definition of application extensions,
    by registration of callbacks.  These extension mechanisms
    are exposed by {docref SQLiteDatabase}.
}

{itemize
    {item {bold functions and aggregates}
        The built-in SQLite functions can be extended using
        {docref SQLiteDatabase.install-function}.
        A {bold function} computes a value from its arguments,
        and can be used anywhere a value is expected.
        An {bold aggregation function} accumulates values
        from a set of records, and must be used in a statement
        with a {ctext GROUP BY} partition. 
    }
    {item {bold authorizers}
        These allow the full range of SQL statements to be restricted.
        This would be useful, for example, when processing user-supplied
        SQL, to disallow modification oprations.
        Use {docref SQLiteDatabase.authorizer} to supply a function
        that will be called before any statement is prepared,
        in order to allow or deny the correponding kind of operation.
    }
}

{x-example-ref title = {message Install Function},
    {url "install-function.curl"}
}

{x-example-ref title = {message Install Aggregate Function},
    {url "install-aggregate.curl"}
}

{x-example-ref title = {message Authorization},
    {url "authorization.curl"}
}

|| ====================
{heading level=3,
   Operational considerations
}
{paragraph
   TODO.
}

{itemize
    {item HTTP considerations}
    {item server interaction}
    || consider change log
    {item lifecycle and resource usage}
    {item transactions and locking}
    {item concurrency}
    {item attached databases}
    || copy example
    {item pragma settings}
}

|| ====================
{heading level=3,
   More about SQLITE
}
{paragraph
   TODO.
}

{itemize
    {item See website for primary docs}
    {item Recommend book}
}

|| ====================
{heading level=2,
    SQLITE Samples
}
{paragraph
   TODO.
}

||-- scenarios
||-- * basic
||-- ** create
||-- ** populate
||-- ** query
||-- *** exists, value, row, col, rows
||-- * advanced sql
||-- ** triggers
||-- ** constraints
||-- ** views
||-- * parameterized queries
||-- ** API
||-- ** callbacks
||-- ** functions
||-- * concurrency

|| ====================
{heading level=3,
   Examples
}
{itemize
    {item order entry}
    {item aggregation}
    {item undo history}
    {item settings}
    {item logging}
    {item example index}
    {item translation history}
    {item OCC}
}

|| ====================
{curl-copyright}

