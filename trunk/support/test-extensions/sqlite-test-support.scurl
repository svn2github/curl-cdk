||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{curl 6.0 package}

{package COM.CURL.CDK.SQLITE-TEST-SUPPORT,
    {compiler-directives
        careful? = true
    }
}
{import * from COM.CURL.CDU.CURL-UNIT}
{import * from COM.CURL.CDK.SQLITE}

|| ====================
{define-proc public {any-equal? x:any, y:any}:bool
    def array-equal? =
        {proc {xs:any, ys:any}:bool
            {with-compiler-directives allow-any-calls? = true do
                {if xs.size != ys.size then
                    {return false}
                }
                {for xv key i in xs do
                    {if not {any-equal? xv, ys[i]} then
                        {return false}
                    }
                }}
            {return true}
        }
    {if x == y then
        {return true}
    }
    {type-switch x
     case xs:ByteArray do
        {type-switch y
         case ys:ByteArray do
            {if {xs.equal? ys} then
                {return true}
            }
        }
     case xs:Array do
        {type-switch y
         case ys:Array do
            {return {array-equal? xs, ys}}
        }
     case xs:{Array-of Array} do
        {type-switch y
         case ys:{Array-of Array} do
            {return {array-equal? xs, ys}}
        }
    }
    {return false}
}
{define-proc public {get-temp-database-file}:Url
    {return
        {get-temp-filename extension = ".db"}}
}
{define-proc public {import-csv-files db:SQLiteDatabase, locs:UrlArray}:void
    {for loc in locs do
        {SQLiteStatement.import-csv db, loc.basename, loc}
    }
}
|| ====================
{define-class public SQLiteDatabaseTestSuite {inherits TestSuite}
  field public-get constant location:#Url
  field public-get constant database:SQLiteDatabase
  {constructor public {default 
                          location:#Url,
                          init-proc:#{proc-type {SQLiteDatabase}:void} = null
                      }
    set self.location = location
    {construct-super
        {if-non-null location 
         then location.filename 
         else ":memory:"}}
    set self.database = {SQLiteDatabase self.location}
    {if-non-null init-proc then
        {init-proc self.database}}
    {self.generate-tests}
  }
  {method {generate-tests}:void
    def tables = 
        {self.database.sql-column
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"}
    {for table in tables do
        {self.add
            {self.generate-test table asa String, "table"}}}
    def views = 
        {self.database.sql-column
            "SELECT name FROM sqlite_master WHERE type='view' ORDER BY name"}
    {for view in views do
        {self.add
            {self.generate-test view asa String, "view"}}}
  }
  {method {generate-test name:String, kind:String}:Test
    {return
        {test-case name,
            def xs =
                {self.database.sql-rows
                    {format "SELECT * from %s", name}}
            {TestCondition.succeed message = 
                {lmessage {value kind} '{value name}' : {value xs.size} rows}}
        }}
  }
}
{define-class public SQLiteTableRecordSetsTestSuite {inherits TestSuite}
  field public-get constant location:#Url
  field public-get constant connection:SQLiteConnection
  {constructor public {default 
                          location:#Url,
                          init-proc:#{proc-type {SQLiteDatabase}:void} = null
                      }
    set self.location = location
    {construct-super
        {if-non-null location 
         then location.filename 
         else ":memory:"}}
    def database = {SQLiteDatabase self.location}
    {if-non-null init-proc then
        {init-proc database}}
    set self.connection = {SQLiteConnection database = database}
    {self.generate-tests}
  }
  {method {generate-tests}:void
    def database = self.connection.database
    def tables = 
        {database.sql-column
            "SELECT name FROM sqlite_master WHERE NOT name LIKE 'sqlite_%' AND type='table' ORDER BY name"}
    {for table in tables do
        {self.add
            {SQLiteTableRecordSetTestCase self.connection, table asa String}}}
  }
}
{define-class public SQLiteTableRecordSetTestCase {inherits TestCase}
  field public-get constant connection:SQLiteConnection
  field public-get constant table:String
  {constructor public {default connection:SQLiteConnection, table:String}
    set self.connection = connection
    set self.table = table
    {construct-super table}
  }
  {method public {run}:void
    def db = self.connection.database
    def table = self.table
    def s-count =
        {SQLiteStatement db,
            {format "SELECT count(*) FROM %s", table}}
    def s-select =        
        {SQLiteStatement db,
            {format "SELECT * FROM %s ORDER BY ROWID", table}}
    
    || first two rows
    {s-select.step}
    def row1 = s-select.current-row
    {s-select.step}
    def row2 = s-select.current-row
    {s-select.reset}
    
    || working recordset
    def rs =
        {self.connection.create-sql-record-set 
            "main", s-select.sql, 
            table-name = table,
            query-is-full-row? = true,
            request-modifiable? = true}
    
    || column names
    def ks = {StringArray}
    {for f in rs.fields do
        {ks.append f.name}}
    
    || delete first two records
    || --------------------
    def iter = {rs.to-Iterator}
    def r1 = {iter.read-one}
    def r2 = {iter.read-one}
    {iter.reset}
    {r1.delete}
    {r2.delete}
    {rs.commit}
    || counts should match
    {TestCondition.assert {s-count.data-value} == rs.size,
        message = {lmessage counts after delete}}
    
    || reinsert first record
    || --------------------
    def rr1 = {rs.new-record}
    {for k key i in ks do
        set rr1[k] = row1[i]}
    {rs.append rr1}
    {rs.commit}
    || counts should still match
    {TestCondition.assert {s-count.data-value} == rs.size,
        message = {lmessage counts after insert}}
    
    || modify first with values from second
    || --------------------
    {for k key i in ks do
        set rr1[k] = row2[i]}
    || reinsert first record
    def rr2 = {rs.new-record}
    {for k key i in ks do
        set rr2[k] = row1[i]}
    {rs.append rr2}
    {rs.commit}
    || counts should still match
    {TestCondition.assert {s-count.data-value} == rs.size,
        message = {lmessage counts after update}}
    
    || values should match
    || --------------------
    let match?:bool = true
    {for k key i in ks do
        {if rr1[k] != row2[i] then
            set match? = false
            {break}}
        {if rr2[k] != row1[i] then
            set match? = false
            {break}}
    }
    {TestCondition.assert match?,
        message = {lmessage row data consistency}}
  }
}
