||| Copyright (C) 1998-2007, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{curl 6.0 package}

{package COM.CURL.CDK.SQLITE-TEST-SUPPORT,
    {compiler-directives
        careful? = true
    }
}
{import * from COM.CURL.CDU.CURL-UNIT}
{import * from COM.CURL.CDK.SQLITE}
||--{import * from CURL.DATA-ACCESS.BASE}

|| ====================
{define-proc public {any-equal? x:any, y:any}:bool
    def array-equal? =
        {proc {xs:any, ys:any}:bool
            {with-compiler-directives allow-any-calls? = true do
                {if xs.size != ys.size then
                    {return false}
                }
                {for xv key i in xs do
                    {if not {any-equal? xv, ys[i]} then
                        {return false}
                    }
                }}
            {return true}
        }
    {if x == y then
        {return true}
    }
    {type-switch x
     case xs:ByteArray do
        {type-switch y
         case ys:ByteArray do
            {if {xs.equal? ys} then
                {return true}
            }
        }
     case xs:Array do
        {type-switch y
         case ys:Array do
            {return {array-equal? xs, ys}}
        }
     case xs:{Array-of Array} do
        {type-switch y
         case ys:{Array-of Array} do
            {return {array-equal? xs, ys}}
        }
    }
    {return false}
}
{define-proc public {get-temp-database-file}:Url
    {return
        {get-temp-filename extension = ".db"}}
}
{define-proc public {import-csv-files db:SQLiteDatabase, locs:UrlArray}:void
    {for loc in locs do
        {SQLiteStatement.import-csv db, loc.basename, loc}
    }
}
|| ====================
{define-class public SQLiteDatabaseTestSuite {inherits TestSuite}
  field public-get constant location:#Url
  field public-get constant database:SQLiteDatabase
  {constructor public {default 
                          location:#Url,
                          init-proc:#{proc-type {SQLiteDatabase}:void} = null
                      }
    set self.location = location
    {construct-super
        {if-non-null location 
         then location.filename 
         else ":memory:"}}
    set self.database = {SQLiteDatabase self.location}
    {if-non-null init-proc then
        {init-proc self.database}}
    {self.generate-tests}
  }
  {method {generate-tests}:void
    def tables = 
        {self.database.sql-column
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"}
    {for table in tables do
        {self.add
            {self.generate-test table asa String, "table"}}}
    def views = 
        {self.database.sql-column
            "SELECT name FROM sqlite_master WHERE type='view' ORDER BY name"}
    {for view in views do
        {self.add
            {self.generate-test view asa String, "view"}}}
  }
  {method {generate-test name:String, kind:String}:Test
    {return
        {test-case name,
            def xs =
                {self.database.sql-rows
                    {format "SELECT * from %s", name}}
            {TestCondition.succeed message = 
                {lmessage {value kind} '{value name}' : {value xs.size} rows}}
        }}
  }
}
