||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{curl 6.0 applet}
{applet manifest = "../manifest.mcurl",
    {compiler-directives careful? = true}
}
{import * from COM.CURL.CDK.SQLITE}
{document-style PlainDocument}
{set-document-properties hstretch? = true, vstretch? = true}

|| ==============================
{import * from COM.CURL.CDK.SQLITE-LIBRARY}
{import CPointer, unsafe-memory-get from CURL.LANGUAGE.DLL-INTERFACE}
{import * from CURL.LANGUAGE.REGEXP}

|| ====================

|| TODO: restargs, any

{define-class public SQLiteFunctionLibrary {inherits {HashTable-of String, SQLiteFunction}}
  {constructor public {default ...:SQLiteFunction}
    {construct-super}
    {for f in ... do
        {self.add-function f}}
  }
  {method {add-function function:SQLiteFunction}:void
    let k:String = function.identifier
    set self[k] = function
  }
  {method {remove-function function:SQLiteFunction}:void
    let k:String = function.identifier
    {self.remove k, error-if-missing? = false}
  }
  {method {register db:SQLiteDatabase}:void
    {for f in self do
        {f.register db}}
  }
  {method {unregister db:SQLiteDatabase}:void
    {for f in self do
        {f.unregister db}}
  }
}
{define-class public SQLiteFunction
  field public-get constant name:String
  field public-get constant num-args:int
  field public-get constant function:any
  field public-get constant type:ProcType
  field public-get constant identifier:String
  field constant unmarshal:{proc-type {SQLiteInterface, int, CPointer}:Array}
  field constant marshal:{proc-type {SQLiteInterface, CPointer, any}:void}
  field constant callback:{proc-type {CPointer, int, CPointer}:void}
  
  {constructor public {default name:String, function:any}
    set self.name = name
    set self.function = function
    set self.type = {type-of function} asa ProcType
    set (self.unmarshal, self.num-args) = {SQLiteFunction.args-for-proc self.type}
    set self.marshal = {SQLiteFunction.result-for-proc self.type}
    let constant interface:SQLiteInterface = {SQLiteInterface}
    set self.callback = 
        {proc {context:CPointer, n:int, args:CPointer}:void
            let xs:Array = {self.unmarshal interface, n, args}
            let result:any = 
                {with-compiler-directives allow-any-calls? = true do
                    {function {splice xs}}}
            {self.marshal interface, context, result}}
    set self.identifier = {format "%s:%s", self.name, self.num-args}
  }
  {method {register db:SQLiteDatabase}:void
    let constant interface:SQLiteInterface = {SQLiteInterface}
    {interface.create-function db.non-null-sqlite3, 
        self.name, 
        self.num-args,
        |# userdata #| 0,
        self.callback,
        |# xstep  #| 0, 
        |# xfinal #| 0
    }
  }
  {method {unregister db:SQLiteDatabase}:void
    let constant interface:SQLiteInterface = {SQLiteInterface}
    {interface.create-function db.non-null-sqlite3, 
        self.name, 
        self.num-args,
        |# userdata #| 0,
        |# xfunc  #| 0, 
        |# xstep  #| 0, 
        |# xfinal #| 0
    }
  }

  || transitional
  {define-proc {args-for-proc
                   p:ProcType
               }:({proc-type {SQLiteInterface, int, CPointer}:Array},
                  int)
    || verify signature
    {if p.num-keyword-args > 0 then
        {error {lmessage args-for: keyword arguments not supported.}}
     elseif p.takes-rest-args? then
        {if p.num-args > 0 then
            {error {lmessage args-for: rest arguments not supported with positional arguments.}}
         else
            {error {lmessage args-for: rest arguments not yet implemented.}}
            || generate unmarshal proc for restargs
            {return
                {proc {interface:SQLiteInterface, n-args:int, args:CPointer}:Array
                    || unmarshal arguments
                    let xs:Array = {Array}
                    {for i = 0 below n-args do
                        let _t:int = {interface.value-type i}
                        let t:SQLiteDatatype = {SQLiteDatatype value = _t}
                        let _x:CPointer = {unsafe-memory-get CPointer, args, index = i}
                        let x:any = 
                            {switch t
                             case SQLiteDatatype.TEXT do {interface.value-text _x}
                             case SQLiteDatatype.INTEGER do
                                let v:int64 = {interface.value-int64 _x}
                                {if v < max-int64 then
                                    v asa int
                                 else v}
                             case SQLiteDatatype.REAL do {interface.value-double _x}
                             case SQLiteDatatype.BLOB do 
                                let n:int = {interface.value-bytes _x}
                                let bytes:ByteArray = {ByteArray efficient-size = n}
                                let _bytes:CPointer = {interface.value-blob _x}
                                {for j = 0 below n do
                                    {bytes.append {unsafe-memory-get byte, _bytes, index = j}}}
                                bytes
                             case SQLiteDatatype.NULL do null
                             else {unreachable}}
                        {xs.append x}}
                    {return xs}
                },
                || restargs
                -1}
        }}
    || note argument types
    let types:{Array-of Type} = {{Array-of Type}}
    {for i = 0 below p.num-args do
        let t:Type = {p.arg-type i}
        {switch t
         case String, int, int64, double, ByteArray do
            || valid
         else
            {error {lmessage args-for: unexpected type: {value t}}}}
        {types.append t}}
    || generate unmarshal proc
    {return
        {proc {interface:SQLiteInterface, n-args:int, args:CPointer}:Array
            || verify argument count
            {if n-args != types.size then
                {error 
                    {lmessage expected {value types.size} arguments but got {value n-args}}}}
            || unmarshal arguments
            let xs:Array = {Array efficient-size = types.size}
            {for t key i in types do
                let _x:CPointer = {unsafe-memory-get CPointer, args, index = i}
                let x:any = 
                    {switch t
                     case String do {interface.value-text _x}
                     case int do {interface.value-int _x}
                     case int64 do {interface.value-int64 _x}
                     case double do {interface.value-double _x}
                     case ByteArray do 
                        let n:int = {interface.value-bytes _x}
                        let bytes:ByteArray = {ByteArray efficient-size = n}
                        let _bytes:CPointer = {interface.value-blob _x}
                        {for j = 0 below n do
                            {bytes.append {unsafe-memory-get byte, _bytes, index = j}}}
                        bytes
                     else {unreachable}}
                {xs.append x}}
            {return xs}
        },
        types.size}
  }
  {define-proc {result-for-proc p:ProcType}:{proc-type {SQLiteInterface, CPointer, any}:void}
    || verify signature
    {if p.num-rets != 1 then
        {error {lmessage result-for: single return required.}}}
    || note result type
    let t:Type = p.return-types[0]
    {switch t
     case String, int, int64, double, ByteArray, bool do
        || valid
     else
        {error {lmessage args-for: unexpected return type: {value t}}}}
    || generate marshal proc
    {return
        {proc {interface:SQLiteInterface, context:CPointer, x:any}:void
            {type-switch x
             case x:String do {interface.result-text context, x}
             case x:bool do {interface.result-int context, {if x then 1 else 0}}
             case x:int do {interface.result-int context, x}
             case x:int64 do {interface.result-int64 context, x}
             case x:double do {interface.result-double context, x}
             case x:ByteArray do {interface.result-blob context, x}
             else {unreachable}}
        }}
  }
}
|| ==============================
{define-proc {f-regexp pattern:String, text:String}:bool
    {return {regexp-match? pattern, text}}
}

{value
    let con:SQLiteConnection = {SQLiteConnection {url "census.db"}}
    let db:SQLiteDatabase = con.database
    
    let fs:SQLiteFunctionLibrary = 
        {SQLiteFunctionLibrary
            {SQLiteFunction "regexp", f-regexp}}
    {fs.register db}
   
    let create-rs:{proc-type {String}:RecordSet} =
        {proc {name:String}:RecordSet
            let w:StopWatch = {StopWatch}
            {w.start}
            let rs:RecordSet = 
                {con.create-record-set "main", name, 
                    request-modifiable? = true}
            {w.stop}
            let msg:String =
                {message Query returned {value rs.size} records in {w.elapsed}}
            {output msg}
            {{get-the-applet}.set-status msg}
            {return rs}
        }
    
    let tables:StringArray = {con.get-tables "main"}
    
    let display:RecordGrid = 
        {RecordGrid 
            width = {add-stretch}, 
            height = {add-stretch}}
    
    let sample-query:String = "SELECT * FROM census WHERE education REGEXP 'school'"
    
    {VBox
        hstretch? = true,
        {HBox 
            {ComboBox vorigin = 70%,
                width = 6in,
                sample-query,
                {splice tables},
                {on ValueFinished at c:ComboBox do
                    {with-busy-cursor
                        let rs:RecordSet = {create-rs c.value asa String}
                        set display.record-source = rs}},
                {on AttachEvent at c:ComboBox do
                    {c.set-value-with-events sample-query}}},
            {Fill}},
        {hrule},
        display}
}
