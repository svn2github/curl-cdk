||| Copyright (C) 1998-2008, Sumisho Computer Systems Corp.  All Rights Reserved.
|||
||| An OpenCurl project.

||| Licensed under the Apache License, Version 2.0 (the "License");
||| you may not use this file except in compliance with the License.
||| You may obtain a copy of the License at
||| 
|||     http://www.apache.org/licenses/LICENSE-2.0
||| 
||| Unless required by applicable law or agreed to in writing, software
||| distributed under the License is distributed on an "AS IS" BASIS,
||| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
||| See the License for the specific language governing permissions and
||| limitations under the License.

{define-class public PollCommandMessageResponder {inherits MessageResponder}

    {constructor public {default
                            agent:#MessageAgent,
                            imessage:IMessage,
                            channel:PollingChannel
                        }
      {construct-super agent, imessage, channel = channel}
      set self.result-handler =
          {proc {msg:IMessage}:void
              let polling-channel:PollingChannel =
                  self.channel asa PollingChannel
              set polling-channel.poll-outstanding? = false
              {type-switch msg
               case cm:CommandMessage do
                  {if {cm.headers.key-exists? CommandMessage.NO_OP_POLL_HEADER}
                      and cm.headers[CommandMessage.NO_OP_POLL_HEADER] == true
                   then
                      {return}
                  }
                  {type-switch cm.body
                   case messages:{Array-of any} do
                      {for message in messages do
                          || TODO: We expect IMessages here, but the current
                          ||       deserializer buries them in an DataObject.
                          {type-switch message
                           case amf-obj:DataObject do
                              {switch amf-obj.traits.name
                               case "flex.messaging.messages.AsyncMessage" do
                                  def async-message =
                                      {self.async-message-from-amf-object
                                          amf-obj
                                      }
                                  {channel.enqueue-event
                                      {new MessageEvent,
                                          MessageEvent.MESSAGE,
                                          message = async-message
                                      }
                                  }
                              }
||--                           case item:IMessage do
||--                              {channel.enqueue-event
||--                                  {new MessageEvent,
||--                                      MessageEvent.MESSAGE,
||--                                      message = item
||--                                  }
||--                              }
                           else
                              || TODO: The Flex code seems to imply that we'll
                              ||       only ever get IMessages, but that has yet
                              ||       to be confirmed by any documentation. For
                              ||       now we just ignore anything that isn't an
                              ||       IMessage.
                          }
                      }
                  }
               case am:AcknowledgeMessage do
                  || This case intentionally left blank.
               else
                  def err = {new ErrorMessage}
                  set err.fault-detail = "Received null"
                  {self.status err}
                  {return}
              }
              {if polling-channel.connected? and polling-channel.should-poll?
               then
                  let adaptive-poll-wait:int = 0
                  {if {msg.headers.key-exists? CommandMessage.POLL_WAIT_HEADER}
                      and msg.headers[CommandMessage.POLL_WAIT_HEADER] != null
                   then
                      set adaptive-poll-wait =
                          msg.headers[CommandMessage.POLL_WAIT_HEADER] asa int
                  }
                  {if adaptive-poll-wait == 0 then
                      {if polling-channel.polling-interval == 0s then
                          {polling-channel.poll}
                       elseif not {polling-channel.timer-running?} then
                          set polling-channel._timer.interval =
                              polling-channel.polling-interval
                          || NOTE: There might be a bug in Flex's timer. The
                          ||       timer is set up with a repeat count of one,
                          ||       but will run at least once every time
                          ||       timer.start() is called regardless of the
                          ||       timer.currentCount value. To simulate this
                          ||       behavior, I reset the timer's repeat value
                          ||       as well.
                          set polling-channel._timer.repeat = 1
                          {polling-channel._timer.enable}
                      }
                   else
                      set polling-channel._timer.interval =
                          adaptive-poll-wait * 1s
                      set polling-channel._timer.repeat = 1
                      {polling-channel._timer.enable}
                  }
              }
          }
      set self.status-handler =
          {proc {msg:IMessage}:void
              let polling-channel:PollingChannel =
                  self.channel asa PollingChannel
              {polling-channel.stop-polling}
              def details =
                  {type-switch msg
                   case err:ErrorMessage do
                      err.fault-detail
                   else
                      ""
                  }
              def fault-event =
                  {new ChannelFaultEvent,
                      ChannelFaultEvent.FAULT,
                      channel = polling-channel,
                      code = "Channel.Polling.Error",
                      level = "error",
                      description = details,
                      root-cause = msg
                  }
              {type-switch msg
               case err:ErrorMessage do
                  {if err.fault-code == "Server.PollNotSupported" then
                      {polling-channel.poll-failed rejected? = true}
                   else
                      {polling-channel.poll-failed rejected? = false}
                  }
               else
                  {polling-channel.poll-failed rejected? = false}
              }
          }
    }

  {method protected {async-message-from-amf-object
                        amf-obj:DataObject
                    }:AsyncMessage
    def async-message = {new AsyncMessage}
    set async-message.headers =
        amf-obj["headers"] asa {HashTable-of String, any}
    set async-message.body = amf-obj["body"]
    set async-message.message-id = amf-obj["messageId"] asa String
    set async-message.client-id = amf-obj["clientId"] asa #String
    set async-message.correlation-id =
        {if-non-null d = amf-obj["correlationId"] then
            d asa String
         else
            ""
        }
    set async-message.destination =
        {if-non-null d = amf-obj["destination"] then
            d asa String
         else
            ""
        }
    set async-message.time-to-live = amf-obj["timeToLive"] asa double
    set async-message.timestamp = amf-obj["timestamp"] asa double
    {return async-message}
  }
}
